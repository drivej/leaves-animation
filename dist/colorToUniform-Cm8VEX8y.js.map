{"version":3,"file":"colorToUniform-Cm8VEX8y.js","sources":["../node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs","../node_modules/pixi.js/lib/filters/Filter.mjs","../node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs","../node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs","../node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs"],"sourcesContent":["\"use strict\";\nconst blendModeIds = {\n  normal: 0,\n  add: 1,\n  multiply: 2,\n  screen: 3,\n  overlay: 4,\n  erase: 5,\n  \"normal-npm\": 6,\n  \"add-npm\": 7,\n  \"screen-npm\": 8,\n  min: 9,\n  max: 10\n};\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\nconst _State = class _State {\n  constructor() {\n    this.data = 0;\n    this.blendMode = \"normal\";\n    this.polygonOffset = 0;\n    this.blend = true;\n    this.depthMask = true;\n  }\n  /**\n   * Activates blending of the computed fragment color values.\n   * @default true\n   */\n  get blend() {\n    return !!(this.data & 1 << BLEND);\n  }\n  set blend(value) {\n    if (!!(this.data & 1 << BLEND) !== value) {\n      this.data ^= 1 << BLEND;\n    }\n  }\n  /**\n   * Activates adding an offset to depth values of polygon's fragments\n   * @default false\n   */\n  get offsets() {\n    return !!(this.data & 1 << OFFSET);\n  }\n  set offsets(value) {\n    if (!!(this.data & 1 << OFFSET) !== value) {\n      this.data ^= 1 << OFFSET;\n    }\n  }\n  /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */\n  set cullMode(value) {\n    if (value === \"none\") {\n      this.culling = false;\n      return;\n    }\n    this.culling = true;\n    this.clockwiseFrontFace = value === \"front\";\n  }\n  get cullMode() {\n    if (!this.culling) {\n      return \"none\";\n    }\n    return this.clockwiseFrontFace ? \"front\" : \"back\";\n  }\n  /**\n   * Activates culling of polygons.\n   * @default false\n   */\n  get culling() {\n    return !!(this.data & 1 << CULLING);\n  }\n  set culling(value) {\n    if (!!(this.data & 1 << CULLING) !== value) {\n      this.data ^= 1 << CULLING;\n    }\n  }\n  /**\n   * Activates depth comparisons and updates to the depth buffer.\n   * @default false\n   */\n  get depthTest() {\n    return !!(this.data & 1 << DEPTH_TEST);\n  }\n  set depthTest(value) {\n    if (!!(this.data & 1 << DEPTH_TEST) !== value) {\n      this.data ^= 1 << DEPTH_TEST;\n    }\n  }\n  /**\n   * Enables or disables writing to the depth buffer.\n   * @default true\n   */\n  get depthMask() {\n    return !!(this.data & 1 << DEPTH_MASK);\n  }\n  set depthMask(value) {\n    if (!!(this.data & 1 << DEPTH_MASK) !== value) {\n      this.data ^= 1 << DEPTH_MASK;\n    }\n  }\n  /**\n   * Specifies whether or not front or back-facing polygons can be culled.\n   * @default false\n   */\n  get clockwiseFrontFace() {\n    return !!(this.data & 1 << WINDING);\n  }\n  set clockwiseFrontFace(value) {\n    if (!!(this.data & 1 << WINDING) !== value) {\n      this.data ^= 1 << WINDING;\n    }\n  }\n  /**\n   * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n   * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n   * @default 'normal'\n   */\n  get blendMode() {\n    return this._blendMode;\n  }\n  set blendMode(value) {\n    this.blend = value !== \"none\";\n    this._blendMode = value;\n    this._blendModeId = blendModeIds[value] || 0;\n  }\n  /**\n   * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n   * @default 0\n   */\n  get polygonOffset() {\n    return this._polygonOffset;\n  }\n  set polygonOffset(value) {\n    this.offsets = !!value;\n    this._polygonOffset = value;\n  }\n  toString() {\n    return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;\n  }\n  /**\n   * A quickly getting an instance of a State that is configured for 2d rendering.\n   * @returns a new State with values set for 2d rendering\n   */\n  static for2d() {\n    const state = new _State();\n    state.depthTest = false;\n    state.blend = true;\n    return state;\n  }\n};\n_State.default2d = _State.for2d();\nlet State = _State;\n\nexport { State };\n//# sourceMappingURL=State.mjs.map\n","import { GlProgram } from '../rendering/renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../rendering/renderers/gpu/shader/GpuProgram.mjs';\nimport { Shader } from '../rendering/renderers/shared/shader/Shader.mjs';\nimport { State } from '../rendering/renderers/shared/state/State.mjs';\n\n\"use strict\";\nconst _Filter = class _Filter extends Shader {\n  /**\n   * @param options - The optional parameters of this filter.\n   */\n  constructor(options) {\n    options = { ..._Filter.defaultOptions, ...options };\n    super(options);\n    /** If enabled is true the filter is applied, if false it will not. */\n    this.enabled = true;\n    /**\n     * The gpu state the filter requires to render.\n     * @internal\n     */\n    this._state = State.for2d();\n    this.blendMode = options.blendMode;\n    this.padding = options.padding;\n    if (typeof options.antialias === \"boolean\") {\n      this.antialias = options.antialias ? \"on\" : \"off\";\n    } else {\n      this.antialias = options.antialias;\n    }\n    this.resolution = options.resolution;\n    this.blendRequired = options.blendRequired;\n    this.clipToViewport = options.clipToViewport;\n    this.addResource(\"uTexture\", 0, 1);\n    if (options.blendRequired) {\n      this.addResource(\"uBackTexture\", 0, 3);\n    }\n  }\n  /**\n   * Applies the filter\n   * @param filterManager - The renderer to retrieve the filter from\n   * @param input - The input render target.\n   * @param output - The target to output to.\n   * @param clearMode - Should the output be cleared before rendering to it\n   */\n  apply(filterManager, input, output, clearMode) {\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n  /**\n   * Get the blend mode of the filter.\n   * @default \"normal\"\n   */\n  get blendMode() {\n    return this._state.blendMode;\n  }\n  /** Sets the blend mode of the filter. */\n  set blendMode(value) {\n    this._state.blendMode = value;\n  }\n  /**\n   * A short hand function to create a filter based of a vertex and fragment shader src.\n   * @param options\n   * @returns A shiny new PixiJS filter!\n   */\n  static from(options) {\n    const { gpu, gl, ...rest } = options;\n    let gpuProgram;\n    let glProgram;\n    if (gpu) {\n      gpuProgram = GpuProgram.from(gpu);\n    }\n    if (gl) {\n      glProgram = GlProgram.from(gl);\n    }\n    return new _Filter({\n      gpuProgram,\n      glProgram,\n      ...rest\n    });\n  }\n};\n/** The default filter settings */\n_Filter.defaultOptions = {\n  blendMode: \"normal\",\n  resolution: 1,\n  padding: 0,\n  antialias: \"off\",\n  blendRequired: false,\n  clipToViewport: true\n};\nlet Filter = _Filter;\n\nexport { Filter };\n//# sourceMappingURL=Filter.mjs.map\n","\"use strict\";\nconst localUniformBit = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `\n    ),\n    end: (\n      /* wgsl */\n      `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    )\n  }\n};\nconst localUniformBitGroup2 = {\n  ...localUniformBit,\n  vertex: {\n    ...localUniformBit.vertex,\n    // replace the group!\n    header: localUniformBit.vertex.header.replace(\"group(1)\", \"group(2)\")\n  }\n};\nconst localUniformBitGl = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `\n    ),\n    end: (\n      /* glsl */\n      `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    )\n  }\n};\n\nexport { localUniformBit, localUniformBitGl, localUniformBitGroup2 };\n//# sourceMappingURL=localUniformBit.mjs.map\n","\"use strict\";\nclass BatchableSprite {\n  constructor() {\n    this.batcherName = \"default\";\n    this.topology = \"triangle-list\";\n    // batch specific..\n    this.attributeSize = 4;\n    this.indexSize = 6;\n    this.packAsQuad = true;\n    this.roundPixels = 0;\n    this._attributeStart = 0;\n    // location in the buffer\n    this._batcher = null;\n    this._batch = null;\n  }\n  get blendMode() {\n    return this.renderable.groupBlendMode;\n  }\n  get color() {\n    return this.renderable.groupColorAlpha;\n  }\n  reset() {\n    this.renderable = null;\n    this.texture = null;\n    this._batcher = null;\n    this._batch = null;\n    this.bounds = null;\n  }\n  destroy() {\n    this.reset();\n  }\n}\n\nexport { BatchableSprite };\n//# sourceMappingURL=BatchableSprite.mjs.map\n","\"use strict\";\nfunction colorToUniform(rgb, alpha, out, offset) {\n  out[offset++] = (rgb >> 16 & 255) / 255;\n  out[offset++] = (rgb >> 8 & 255) / 255;\n  out[offset++] = (rgb & 255) / 255;\n  out[offset++] = alpha;\n}\nfunction color32BitToUniform(abgr, out, offset) {\n  const alpha = (abgr >> 24 & 255) / 255;\n  out[offset++] = (abgr & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 8 & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 16 & 255) / 255 * alpha;\n  out[offset++] = alpha;\n}\n\nexport { color32BitToUniform, colorToUniform };\n//# sourceMappingURL=colorToUniform.mjs.map\n"],"names":["blendModeIds","BLEND","OFFSET","CULLING","DEPTH_TEST","WINDING","DEPTH_MASK","_State","value","state","State","_Filter","Shader","options","filterManager","input","output","clearMode","gpu","gl","rest","gpuProgram","glProgram","GpuProgram","GlProgram","Filter","localUniformBit","localUniformBitGroup2","localUniformBitGl","BatchableSprite","color32BitToUniform","abgr","out","offset","alpha"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4]}