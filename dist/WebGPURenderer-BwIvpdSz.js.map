{"version":3,"file":"WebGPURenderer-BwIvpdSz.js","sources":["../node_modules/pixi.js/lib/rendering/batcher/gpu/GpuBatchAdaptor.mjs","../node_modules/pixi.js/lib/rendering/renderers/gpu/BindGroupSystem.mjs","../node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.mjs","../node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/UboBatch.mjs","../node_modules/pixi.js/lib/rendering/renderers/gpu/GpuColorMaskSystem.mjs","../node_modules/pixi.js/lib/rendering/renderers/gpu/GpuDeviceSystem.mjs","../node_modules/pixi.js/lib/rendering/renderers/gpu/GpuEncoderSystem.mjs","../node_modules/pixi.js/lib/rendering/renderers/gpu/GpuLimitsSystem.mjs","../node_modules/pixi.js/lib/rendering/renderers/gpu/GpuStencilSystem.mjs","../node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.mjs","../node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.mjs","../node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.mjs","../node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUboSystem.mjs","../node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBatchPipe.mjs","../node_modules/pixi.js/lib/rendering/renderers/gpu/pipeline/PipelineSystem.mjs","../node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs","../node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.mjs","../node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs","../node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuShaderSystem.mjs","../node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs","../node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStateSystem.mjs","../node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs","../node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.mjs","../node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs","../node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.mjs","../node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs","../node_modules/pixi.js/lib/rendering/renderers/gpu/texture/GpuTextureSystem.mjs","../node_modules/pixi.js/lib/scene/graphics/gpu/GpuGraphicsAdaptor.mjs","../node_modules/pixi.js/lib/scene/mesh/gpu/GpuMeshAdapter.mjs","../node_modules/pixi.js/lib/rendering/renderers/gpu/WebGPURenderer.mjs"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { State } from '../../renderers/shared/state/State.mjs';\nimport { getTextureBatchBindGroup } from './getTextureBatchBindGroup.mjs';\n\n\"use strict\";\nconst tempState = State.for2d();\nclass GpuBatchAdaptor {\n  start(batchPipe, geometry, shader) {\n    const renderer = batchPipe.renderer;\n    const encoder = renderer.encoder;\n    const program = shader.gpuProgram;\n    this._shader = shader;\n    this._geometry = geometry;\n    encoder.setGeometry(geometry, program);\n    tempState.blendMode = \"normal\";\n    renderer.pipeline.getPipeline(\n      geometry,\n      program,\n      tempState\n    );\n    const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n    encoder.resetBindGroup(1);\n    encoder.setBindGroup(0, globalUniformsBindGroup, program);\n  }\n  execute(batchPipe, batch) {\n    const program = this._shader.gpuProgram;\n    const renderer = batchPipe.renderer;\n    const encoder = renderer.encoder;\n    if (!batch.bindGroup) {\n      const textureBatch = batch.textures;\n      batch.bindGroup = getTextureBatchBindGroup(\n        textureBatch.textures,\n        textureBatch.count,\n        renderer.limits.maxBatchableTextures\n      );\n    }\n    tempState.blendMode = batch.blendMode;\n    const gpuBindGroup = renderer.bindGroup.getBindGroup(\n      batch.bindGroup,\n      program,\n      1\n    );\n    const pipeline = renderer.pipeline.getPipeline(\n      this._geometry,\n      program,\n      tempState,\n      batch.topology\n    );\n    batch.bindGroup._touch(renderer.gc.now, renderer.tick);\n    encoder.setPipeline(pipeline);\n    encoder.renderPassEncoder.setBindGroup(1, gpuBindGroup);\n    encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n  }\n}\n/** @ignore */\nGpuBatchAdaptor.extension = {\n  type: [\n    ExtensionType.WebGPUPipesAdaptor\n  ],\n  name: \"batch\"\n};\n\nexport { GpuBatchAdaptor };\n//# sourceMappingURL=GpuBatchAdaptor.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass BindGroupSystem {\n  constructor(renderer) {\n    this._hash = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n  getBindGroup(bindGroup, program, groupIndex) {\n    bindGroup._updateKey();\n    const gpuBindGroup = this._hash[bindGroup._key] || this._createBindGroup(bindGroup, program, groupIndex);\n    return gpuBindGroup;\n  }\n  _createBindGroup(group, program, groupIndex) {\n    const device = this._gpu.device;\n    const groupLayout = program.layout[groupIndex];\n    const entries = [];\n    const renderer = this._renderer;\n    for (const j in groupLayout) {\n      const resource = group.resources[j] ?? group.resources[groupLayout[j]];\n      let gpuResource;\n      if (resource._resourceType === \"uniformGroup\") {\n        const uniformGroup = resource;\n        renderer.ubo.updateUniformGroup(uniformGroup);\n        const buffer = uniformGroup.buffer;\n        gpuResource = {\n          buffer: renderer.buffer.getGPUBuffer(buffer),\n          offset: 0,\n          size: buffer.descriptor.size\n        };\n      } else if (resource._resourceType === \"buffer\") {\n        const buffer = resource;\n        gpuResource = {\n          buffer: renderer.buffer.getGPUBuffer(buffer),\n          offset: 0,\n          size: buffer.descriptor.size\n        };\n      } else if (resource._resourceType === \"bufferResource\") {\n        const bufferResource = resource;\n        gpuResource = {\n          buffer: renderer.buffer.getGPUBuffer(bufferResource.buffer),\n          offset: bufferResource.offset,\n          size: bufferResource.size\n        };\n      } else if (resource._resourceType === \"textureSampler\") {\n        const sampler = resource;\n        gpuResource = renderer.texture.getGpuSampler(sampler);\n      } else if (resource._resourceType === \"textureSource\") {\n        const texture = resource;\n        gpuResource = renderer.texture.getGpuSource(texture).createView();\n      }\n      entries.push({\n        binding: groupLayout[j],\n        resource: gpuResource\n      });\n    }\n    const layout = renderer.shader.getProgramData(program).bindGroups[groupIndex];\n    const gpuBindGroup = device.createBindGroup({\n      layout,\n      entries\n    });\n    this._hash[group._key] = gpuBindGroup;\n    return gpuBindGroup;\n  }\n  destroy() {\n    this._hash = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nBindGroupSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"bindGroup\"\n};\n\nexport { BindGroupSystem };\n//# sourceMappingURL=BindGroupSystem.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { GCManagedHash } from '../../../../utils/data/GCManagedHash.mjs';\nimport { uid } from '../../../../utils/data/uid.mjs';\nimport { fastCopy } from '../../shared/buffer/utils/fastCopy.mjs';\n\n\"use strict\";\nclass GpuBufferData {\n  constructor(gpuBuffer) {\n    this.gpuBuffer = gpuBuffer;\n  }\n  destroy() {\n    this.gpuBuffer.destroy();\n    this.gpuBuffer = null;\n  }\n}\nclass GpuBufferSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n    this._managedBuffers = new GCManagedHash({\n      renderer,\n      type: \"resource\",\n      onUnload: this.onBufferUnload.bind(this),\n      name: \"gpuBuffer\"\n    });\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n  getGPUBuffer(buffer) {\n    buffer._gcLastUsed = this._renderer.gc.now;\n    return buffer._gpuData[this._renderer.uid]?.gpuBuffer || this.createGPUBuffer(buffer);\n  }\n  updateBuffer(buffer) {\n    const gpuBuffer = this.getGPUBuffer(buffer);\n    const data = buffer.data;\n    if (buffer._updateID && data) {\n      buffer._updateID = 0;\n      this._gpu.device.queue.writeBuffer(\n        gpuBuffer,\n        0,\n        data.buffer,\n        0,\n        // round to the nearest 4 bytes\n        (buffer._updateSize || data.byteLength) + 3 & ~3\n      );\n    }\n    return gpuBuffer;\n  }\n  /** dispose all WebGL resources of all managed buffers */\n  destroyAll() {\n    this._managedBuffers.removeAll();\n  }\n  onBufferUnload(buffer) {\n    buffer.off(\"update\", this.updateBuffer, this);\n    buffer.off(\"change\", this.onBufferChange, this);\n  }\n  createGPUBuffer(buffer) {\n    const gpuBuffer = this._gpu.device.createBuffer(buffer.descriptor);\n    buffer._updateID = 0;\n    buffer._resourceId = uid(\"resource\");\n    if (buffer.data) {\n      fastCopy(buffer.data.buffer, gpuBuffer.getMappedRange());\n      gpuBuffer.unmap();\n    }\n    buffer._gpuData[this._renderer.uid] = new GpuBufferData(gpuBuffer);\n    if (this._managedBuffers.add(buffer)) {\n      buffer.on(\"update\", this.updateBuffer, this);\n      buffer.on(\"change\", this.onBufferChange, this);\n    }\n    return gpuBuffer;\n  }\n  onBufferChange(buffer) {\n    this._managedBuffers.remove(buffer);\n    buffer._updateID = 0;\n    this.createGPUBuffer(buffer);\n  }\n  destroy() {\n    this._managedBuffers.destroy();\n    this._renderer = null;\n    this._gpu = null;\n  }\n}\n/** @ignore */\nGpuBufferSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"buffer\"\n};\n\nexport { GpuBufferData, GpuBufferSystem };\n//# sourceMappingURL=GpuBufferSystem.mjs.map\n","\"use strict\";\nclass UboBatch {\n  constructor({ minUniformOffsetAlignment }) {\n    this._minUniformOffsetAlignment = 256;\n    this.byteIndex = 0;\n    this._minUniformOffsetAlignment = minUniformOffsetAlignment;\n    this.data = new Float32Array(65535);\n  }\n  clear() {\n    this.byteIndex = 0;\n  }\n  addEmptyGroup(size) {\n    if (size > this._minUniformOffsetAlignment / 4) {\n      throw new Error(`UniformBufferBatch: array is too large: ${size * 4}`);\n    }\n    const start = this.byteIndex;\n    let newSize = start + size * 4;\n    newSize = Math.ceil(newSize / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment;\n    if (newSize > this.data.length * 4) {\n      throw new Error(\"UniformBufferBatch: ubo batch got too big\");\n    }\n    this.byteIndex = newSize;\n    return start;\n  }\n  addGroup(array) {\n    const offset = this.addEmptyGroup(array.length);\n    for (let i = 0; i < array.length; i++) {\n      this.data[offset / 4 + i] = array[i];\n    }\n    return offset;\n  }\n  destroy() {\n    this.data = null;\n  }\n}\n\nexport { UboBatch };\n//# sourceMappingURL=UboBatch.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass GpuColorMaskSystem {\n  constructor(renderer) {\n    this._colorMaskCache = 15;\n    this._renderer = renderer;\n  }\n  setMask(colorMask) {\n    if (this._colorMaskCache === colorMask)\n      return;\n    this._colorMaskCache = colorMask;\n    this._renderer.pipeline.setColorMask(colorMask);\n  }\n  destroy() {\n    this._renderer = null;\n    this._colorMaskCache = null;\n  }\n}\n/** @ignore */\nGpuColorMaskSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"colorMask\"\n};\n\nexport { GpuColorMaskSystem };\n//# sourceMappingURL=GpuColorMaskSystem.mjs.map\n","import { DOMAdapter } from '../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass GpuDeviceSystem {\n  /**\n   * @param {WebGPURenderer} renderer - The renderer this System works for.\n   */\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  async init(options) {\n    if (this._initPromise)\n      return this._initPromise;\n    this._initPromise = (options.gpu ? Promise.resolve(options.gpu) : this._createDeviceAndAdaptor(options)).then((gpu) => {\n      this.gpu = gpu;\n      this._renderer.runners.contextChange.emit(this.gpu);\n    });\n    return this._initPromise;\n  }\n  /**\n   * Handle the context change event\n   * @param gpu\n   */\n  contextChange(gpu) {\n    this._renderer.gpu = gpu;\n  }\n  /**\n   * Helper class to create a WebGL Context\n   * @param {object} options - An options object that gets passed in to the canvas element containing the\n   *    context attributes\n   * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext\n   * @returns {WebGLRenderingContext} the WebGL context\n   */\n  async _createDeviceAndAdaptor(options) {\n    const adapter = await DOMAdapter.get().getNavigator().gpu.requestAdapter({\n      powerPreference: options.powerPreference,\n      forceFallbackAdapter: options.forceFallbackAdapter\n    });\n    const requiredFeatures = [\n      \"texture-compression-bc\",\n      \"texture-compression-astc\",\n      \"texture-compression-etc2\"\n    ].filter((feature) => adapter.features.has(feature));\n    const device = await adapter.requestDevice({\n      requiredFeatures\n    });\n    return { adapter, device };\n  }\n  destroy() {\n    this.gpu = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGpuDeviceSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"device\"\n};\n/** The default options for the GpuDeviceSystem. */\nGpuDeviceSystem.defaultOptions = {\n  /**\n   * {@link WebGPUOptions.powerPreference}\n   * @default default\n   */\n  powerPreference: void 0,\n  /**\n   * Force the use of the fallback adapter\n   * @default false\n   */\n  forceFallbackAdapter: false\n};\n\nexport { GpuDeviceSystem };\n//# sourceMappingURL=GpuDeviceSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass GpuEncoderSystem {\n  constructor(renderer) {\n    this._boundBindGroup = /* @__PURE__ */ Object.create(null);\n    this._boundVertexBuffer = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  renderStart() {\n    this.commandFinished = new Promise((resolve) => {\n      this._resolveCommandFinished = resolve;\n    });\n    this.commandEncoder = this._renderer.gpu.device.createCommandEncoder();\n  }\n  beginRenderPass(gpuRenderTarget) {\n    this.endRenderPass();\n    this._clearCache();\n    this.renderPassEncoder = this.commandEncoder.beginRenderPass(gpuRenderTarget.descriptor);\n  }\n  endRenderPass() {\n    if (this.renderPassEncoder) {\n      this.renderPassEncoder.end();\n    }\n    this.renderPassEncoder = null;\n  }\n  setViewport(viewport) {\n    this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n  }\n  setPipelineFromGeometryProgramAndState(geometry, program, state, topology) {\n    const pipeline = this._renderer.pipeline.getPipeline(geometry, program, state, topology);\n    this.setPipeline(pipeline);\n  }\n  setPipeline(pipeline) {\n    if (this._boundPipeline === pipeline)\n      return;\n    this._boundPipeline = pipeline;\n    this.renderPassEncoder.setPipeline(pipeline);\n  }\n  _setVertexBuffer(index, buffer) {\n    if (this._boundVertexBuffer[index] === buffer)\n      return;\n    this._boundVertexBuffer[index] = buffer;\n    this.renderPassEncoder.setVertexBuffer(index, this._renderer.buffer.updateBuffer(buffer));\n  }\n  _setIndexBuffer(buffer) {\n    if (this._boundIndexBuffer === buffer)\n      return;\n    this._boundIndexBuffer = buffer;\n    const indexFormat = buffer.data.BYTES_PER_ELEMENT === 2 ? \"uint16\" : \"uint32\";\n    this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(buffer), indexFormat);\n  }\n  resetBindGroup(index) {\n    this._boundBindGroup[index] = null;\n  }\n  setBindGroup(index, bindGroup, program) {\n    if (this._boundBindGroup[index] === bindGroup)\n      return;\n    this._boundBindGroup[index] = bindGroup;\n    bindGroup._touch(this._renderer.gc.now, this._renderer.tick);\n    const gpuBindGroup = this._renderer.bindGroup.getBindGroup(bindGroup, program, index);\n    this.renderPassEncoder.setBindGroup(index, gpuBindGroup);\n  }\n  setGeometry(geometry, program) {\n    const buffersToBind = this._renderer.pipeline.getBufferNamesToBind(geometry, program);\n    for (const i in buffersToBind) {\n      this._setVertexBuffer(parseInt(i, 10), geometry.attributes[buffersToBind[i]].buffer);\n    }\n    if (geometry.indexBuffer) {\n      this._setIndexBuffer(geometry.indexBuffer);\n    }\n  }\n  _setShaderBindGroups(shader, skipSync) {\n    for (const i in shader.groups) {\n      const bindGroup = shader.groups[i];\n      if (!skipSync) {\n        this._syncBindGroup(bindGroup);\n      }\n      this.setBindGroup(i, bindGroup, shader.gpuProgram);\n    }\n  }\n  _syncBindGroup(bindGroup) {\n    for (const j in bindGroup.resources) {\n      const resource = bindGroup.resources[j];\n      if (resource.isUniformGroup) {\n        this._renderer.ubo.updateUniformGroup(resource);\n      }\n    }\n  }\n  draw(options) {\n    const { geometry, shader, state, topology, size, start, instanceCount, skipSync } = options;\n    this.setPipelineFromGeometryProgramAndState(geometry, shader.gpuProgram, state, topology);\n    this.setGeometry(geometry, shader.gpuProgram);\n    this._setShaderBindGroups(shader, skipSync);\n    if (geometry.indexBuffer) {\n      this.renderPassEncoder.drawIndexed(\n        size || geometry.indexBuffer.data.length,\n        instanceCount ?? geometry.instanceCount,\n        start || 0\n      );\n    } else {\n      this.renderPassEncoder.draw(size || geometry.getSize(), instanceCount ?? geometry.instanceCount, start || 0);\n    }\n  }\n  finishRenderPass() {\n    if (this.renderPassEncoder) {\n      this.renderPassEncoder.end();\n      this.renderPassEncoder = null;\n    }\n  }\n  postrender() {\n    this.finishRenderPass();\n    this._gpu.device.queue.submit([this.commandEncoder.finish()]);\n    this._resolveCommandFinished();\n    this.commandEncoder = null;\n  }\n  // restores a render pass if finishRenderPass was called\n  // not optimised as really used for debugging!\n  // used when we want to stop drawing and log a texture..\n  restoreRenderPass() {\n    const descriptor = this._renderer.renderTarget.adaptor.getDescriptor(\n      this._renderer.renderTarget.renderTarget,\n      false,\n      [0, 0, 0, 1]\n    );\n    this.renderPassEncoder = this.commandEncoder.beginRenderPass(descriptor);\n    const boundPipeline = this._boundPipeline;\n    const boundVertexBuffer = { ...this._boundVertexBuffer };\n    const boundIndexBuffer = this._boundIndexBuffer;\n    const boundBindGroup = { ...this._boundBindGroup };\n    this._clearCache();\n    const viewport = this._renderer.renderTarget.viewport;\n    this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n    this.setPipeline(boundPipeline);\n    for (const i in boundVertexBuffer) {\n      this._setVertexBuffer(i, boundVertexBuffer[i]);\n    }\n    for (const i in boundBindGroup) {\n      this.setBindGroup(i, boundBindGroup[i], null);\n    }\n    this._setIndexBuffer(boundIndexBuffer);\n  }\n  _clearCache() {\n    for (let i = 0; i < 16; i++) {\n      this._boundBindGroup[i] = null;\n      this._boundVertexBuffer[i] = null;\n    }\n    this._boundIndexBuffer = null;\n    this._boundPipeline = null;\n  }\n  destroy() {\n    this._renderer = null;\n    this._gpu = null;\n    this._boundBindGroup = null;\n    this._boundVertexBuffer = null;\n    this._boundIndexBuffer = null;\n    this._boundPipeline = null;\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n}\n/** @ignore */\nGpuEncoderSystem.extension = {\n  type: [ExtensionType.WebGPUSystem],\n  name: \"encoder\",\n  priority: 1\n};\n\nexport { GpuEncoderSystem };\n//# sourceMappingURL=GpuEncoderSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass GpuLimitsSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  contextChange() {\n    this.maxTextures = this._renderer.device.gpu.device.limits.maxSampledTexturesPerShaderStage;\n    this.maxBatchableTextures = this.maxTextures;\n  }\n  destroy() {\n  }\n}\n/** @ignore */\nGpuLimitsSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"limits\"\n};\n\nexport { GpuLimitsSystem };\n//# sourceMappingURL=GpuLimitsSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { STENCIL_MODES } from '../shared/state/const.mjs';\n\n\"use strict\";\nclass GpuStencilSystem {\n  constructor(renderer) {\n    this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n    renderer.renderTarget.onRenderTargetChange.add(this);\n  }\n  onRenderTargetChange(renderTarget) {\n    let stencilState = this._renderTargetStencilState[renderTarget.uid];\n    if (!stencilState) {\n      stencilState = this._renderTargetStencilState[renderTarget.uid] = {\n        stencilMode: STENCIL_MODES.DISABLED,\n        stencilReference: 0\n      };\n    }\n    this._activeRenderTarget = renderTarget;\n    this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);\n  }\n  setStencilMode(stencilMode, stencilReference) {\n    const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];\n    stencilState.stencilMode = stencilMode;\n    stencilState.stencilReference = stencilReference;\n    const renderer = this._renderer;\n    renderer.pipeline.setStencilMode(stencilMode);\n    renderer.encoder.renderPassEncoder.setStencilReference(stencilReference);\n  }\n  destroy() {\n    this._renderer.renderTarget.onRenderTargetChange.remove(this);\n    this._renderer = null;\n    this._activeRenderTarget = null;\n    this._renderTargetStencilState = null;\n  }\n}\n/** @ignore */\nGpuStencilSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"stencil\"\n};\n\nexport { GpuStencilSystem };\n//# sourceMappingURL=GpuStencilSystem.mjs.map\n","\"use strict\";\nconst WGSL_ALIGN_SIZE_DATA = {\n  i32: { align: 4, size: 4 },\n  u32: { align: 4, size: 4 },\n  f32: { align: 4, size: 4 },\n  f16: { align: 2, size: 2 },\n  \"vec2<i32>\": { align: 8, size: 8 },\n  \"vec2<u32>\": { align: 8, size: 8 },\n  \"vec2<f32>\": { align: 8, size: 8 },\n  \"vec2<f16>\": { align: 4, size: 4 },\n  \"vec3<i32>\": { align: 16, size: 12 },\n  \"vec3<u32>\": { align: 16, size: 12 },\n  \"vec3<f32>\": { align: 16, size: 12 },\n  \"vec3<f16>\": { align: 8, size: 6 },\n  \"vec4<i32>\": { align: 16, size: 16 },\n  \"vec4<u32>\": { align: 16, size: 16 },\n  \"vec4<f32>\": { align: 16, size: 16 },\n  \"vec4<f16>\": { align: 8, size: 8 },\n  \"mat2x2<f32>\": { align: 8, size: 16 },\n  \"mat2x2<f16>\": { align: 4, size: 8 },\n  \"mat3x2<f32>\": { align: 8, size: 24 },\n  \"mat3x2<f16>\": { align: 4, size: 12 },\n  \"mat4x2<f32>\": { align: 8, size: 32 },\n  \"mat4x2<f16>\": { align: 4, size: 16 },\n  \"mat2x3<f32>\": { align: 16, size: 32 },\n  \"mat2x3<f16>\": { align: 8, size: 16 },\n  \"mat3x3<f32>\": { align: 16, size: 48 },\n  \"mat3x3<f16>\": { align: 8, size: 24 },\n  \"mat4x3<f32>\": { align: 16, size: 64 },\n  \"mat4x3<f16>\": { align: 8, size: 32 },\n  \"mat2x4<f32>\": { align: 16, size: 32 },\n  \"mat2x4<f16>\": { align: 8, size: 16 },\n  \"mat3x4<f32>\": { align: 16, size: 48 },\n  \"mat3x4<f16>\": { align: 8, size: 24 },\n  \"mat4x4<f32>\": { align: 16, size: 64 },\n  \"mat4x4<f16>\": { align: 8, size: 32 }\n};\nfunction createUboElementsWGSL(uniformData) {\n  const uboElements = uniformData.map((data) => ({\n    data,\n    offset: 0,\n    size: 0\n  }));\n  let offset = 0;\n  for (let i = 0; i < uboElements.length; i++) {\n    const uboElement = uboElements[i];\n    let size = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].size;\n    const align = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].align;\n    if (!WGSL_ALIGN_SIZE_DATA[uboElement.data.type]) {\n      throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${uboElement.data.type}`);\n    }\n    if (uboElement.data.size > 1) {\n      size = Math.max(size, align) * uboElement.data.size;\n    }\n    offset = Math.ceil(offset / align) * align;\n    uboElement.size = size;\n    uboElement.offset = offset;\n    offset += size;\n  }\n  offset = Math.ceil(offset / 16) * 16;\n  return { uboElements, size: offset };\n}\n\nexport { WGSL_ALIGN_SIZE_DATA, createUboElementsWGSL };\n//# sourceMappingURL=createUboElementsWGSL.mjs.map\n","import { WGSL_ALIGN_SIZE_DATA } from './createUboElementsWGSL.mjs';\n\n\"use strict\";\nfunction generateArraySyncWGSL(uboElement, offsetToAdd) {\n  const { size, align } = WGSL_ALIGN_SIZE_DATA[uboElement.data.type];\n  const remainder = (align - size) / 4;\n  const data = uboElement.data.type.indexOf(\"i32\") >= 0 ? \"dataInt32\" : \"data\";\n  return `\n         v = uv.${uboElement.data.name};\n         ${offsetToAdd !== 0 ? `offset += ${offsetToAdd};` : \"\"}\n\n         arrayOffset = offset;\n\n         t = 0;\n\n         for(var i=0; i < ${uboElement.data.size * (size / 4)}; i++)\n         {\n             for(var j = 0; j < ${size / 4}; j++)\n             {\n                 ${data}[arrayOffset++] = v[t++];\n             }\n             ${remainder !== 0 ? `arrayOffset += ${remainder};` : \"\"}\n         }\n     `;\n}\n\nexport { generateArraySyncWGSL };\n//# sourceMappingURL=generateArraySyncWGSL.mjs.map\n","import { createUboSyncFunction } from '../../../shared/shader/utils/createUboSyncFunction.mjs';\nimport { uboSyncFunctionsWGSL } from '../../../shared/shader/utils/uboSyncFunctions.mjs';\nimport { generateArraySyncWGSL } from './generateArraySyncWGSL.mjs';\n\n\"use strict\";\nfunction createUboSyncFunctionWGSL(uboElements) {\n  return createUboSyncFunction(\n    uboElements,\n    \"uboWgsl\",\n    generateArraySyncWGSL,\n    uboSyncFunctionsWGSL\n  );\n}\n\nexport { createUboSyncFunctionWGSL };\n//# sourceMappingURL=createUboSyncFunctionWGSL.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { UboSystem } from '../shared/shader/UboSystem.mjs';\nimport { createUboElementsWGSL } from './shader/utils/createUboElementsWGSL.mjs';\nimport { createUboSyncFunctionWGSL } from './shader/utils/createUboSyncFunctionWGSL.mjs';\n\n\"use strict\";\nclass GpuUboSystem extends UboSystem {\n  constructor() {\n    super({\n      createUboElements: createUboElementsWGSL,\n      generateUboSync: createUboSyncFunctionWGSL\n    });\n  }\n}\n/** @ignore */\nGpuUboSystem.extension = {\n  type: [ExtensionType.WebGPUSystem],\n  name: \"ubo\"\n};\n\nexport { GpuUboSystem };\n//# sourceMappingURL=GpuUboSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Buffer } from '../shared/buffer/Buffer.mjs';\nimport { BufferResource } from '../shared/buffer/BufferResource.mjs';\nimport { BufferUsage } from '../shared/buffer/const.mjs';\nimport { UboBatch } from './buffer/UboBatch.mjs';\nimport { BindGroup } from './shader/BindGroup.mjs';\n\n\"use strict\";\nconst minUniformOffsetAlignment = 128;\nclass GpuUniformBatchPipe {\n  constructor(renderer) {\n    this._bindGroupHash = /* @__PURE__ */ Object.create(null);\n    // number of buffers..\n    this._buffers = [];\n    this._bindGroups = [];\n    this._bufferResources = [];\n    this._renderer = renderer;\n    this._batchBuffer = new UboBatch({ minUniformOffsetAlignment });\n    const totalBuffers = 256 / minUniformOffsetAlignment;\n    for (let i = 0; i < totalBuffers; i++) {\n      let usage = BufferUsage.UNIFORM | BufferUsage.COPY_DST;\n      if (i === 0)\n        usage |= BufferUsage.COPY_SRC;\n      this._buffers.push(new Buffer({\n        data: this._batchBuffer.data,\n        usage\n      }));\n    }\n  }\n  renderEnd() {\n    this._uploadBindGroups();\n    this._resetBindGroups();\n  }\n  _resetBindGroups() {\n    this._bindGroupHash = /* @__PURE__ */ Object.create(null);\n    this._batchBuffer.clear();\n  }\n  // just works for single bind groups for now\n  getUniformBindGroup(group, duplicate) {\n    if (!duplicate && this._bindGroupHash[group.uid]) {\n      return this._bindGroupHash[group.uid];\n    }\n    this._renderer.ubo.ensureUniformGroup(group);\n    const data = group.buffer.data;\n    const offset = this._batchBuffer.addEmptyGroup(data.length);\n    this._renderer.ubo.syncUniformGroup(group, this._batchBuffer.data, offset / 4);\n    this._bindGroupHash[group.uid] = this._getBindGroup(offset / minUniformOffsetAlignment);\n    return this._bindGroupHash[group.uid];\n  }\n  getUboResource(group) {\n    this._renderer.ubo.updateUniformGroup(group);\n    const data = group.buffer.data;\n    const offset = this._batchBuffer.addGroup(data);\n    return this._getBufferResource(offset / minUniformOffsetAlignment);\n  }\n  getArrayBindGroup(data) {\n    const offset = this._batchBuffer.addGroup(data);\n    return this._getBindGroup(offset / minUniformOffsetAlignment);\n  }\n  getArrayBufferResource(data) {\n    const offset = this._batchBuffer.addGroup(data);\n    const index = offset / minUniformOffsetAlignment;\n    return this._getBufferResource(index);\n  }\n  _getBufferResource(index) {\n    if (!this._bufferResources[index]) {\n      const buffer = this._buffers[index % 2];\n      this._bufferResources[index] = new BufferResource({\n        buffer,\n        offset: (index / 2 | 0) * 256,\n        size: minUniformOffsetAlignment\n      });\n    }\n    return this._bufferResources[index];\n  }\n  _getBindGroup(index) {\n    if (!this._bindGroups[index]) {\n      const bindGroup = new BindGroup({\n        0: this._getBufferResource(index)\n      });\n      this._bindGroups[index] = bindGroup;\n    }\n    return this._bindGroups[index];\n  }\n  _uploadBindGroups() {\n    const bufferSystem = this._renderer.buffer;\n    const firstBuffer = this._buffers[0];\n    firstBuffer.update(this._batchBuffer.byteIndex);\n    bufferSystem.updateBuffer(firstBuffer);\n    const commandEncoder = this._renderer.gpu.device.createCommandEncoder();\n    for (let i = 1; i < this._buffers.length; i++) {\n      const buffer = this._buffers[i];\n      commandEncoder.copyBufferToBuffer(\n        bufferSystem.getGPUBuffer(firstBuffer),\n        minUniformOffsetAlignment,\n        bufferSystem.getGPUBuffer(buffer),\n        0,\n        this._batchBuffer.byteIndex\n      );\n    }\n    this._renderer.gpu.device.queue.submit([commandEncoder.finish()]);\n  }\n  destroy() {\n    for (let i = 0; i < this._bindGroups.length; i++) {\n      this._bindGroups[i]?.destroy();\n    }\n    this._bindGroups = null;\n    this._bindGroupHash = null;\n    for (let i = 0; i < this._buffers.length; i++) {\n      this._buffers[i].destroy();\n    }\n    this._buffers = null;\n    for (let i = 0; i < this._bufferResources.length; i++) {\n      this._bufferResources[i].destroy();\n    }\n    this._bufferResources = null;\n    this._batchBuffer.destroy();\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGpuUniformBatchPipe.extension = {\n  type: [\n    ExtensionType.WebGPUPipes\n  ],\n  name: \"uniformBatch\"\n};\n\nexport { GpuUniformBatchPipe };\n//# sourceMappingURL=GpuUniformBatchPipe.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { warn } from '../../../../utils/logging/warn.mjs';\nimport { ensureAttributes } from '../../gl/shader/program/ensureAttributes.mjs';\nimport { STENCIL_MODES } from '../../shared/state/const.mjs';\nimport { createIdFromString } from '../../shared/utils/createIdFromString.mjs';\nimport { GpuStencilModesToPixi } from '../state/GpuStencilModesToPixi.mjs';\n\n\"use strict\";\nconst topologyStringToId = {\n  \"point-list\": 0,\n  \"line-list\": 1,\n  \"line-strip\": 2,\n  \"triangle-list\": 3,\n  \"triangle-strip\": 4\n};\nfunction getGraphicsStateKey(geometryLayout, shaderKey, state, blendMode, topology) {\n  return geometryLayout << 24 | shaderKey << 16 | state << 10 | blendMode << 5 | topology;\n}\nfunction getGlobalStateKey(stencilStateId, multiSampleCount, colorMask, renderTarget, colorTargetCount) {\n  return colorMask << 8 | stencilStateId << 5 | renderTarget << 3 | colorTargetCount << 1 | multiSampleCount;\n}\nclass PipelineSystem {\n  constructor(renderer) {\n    this._moduleCache = /* @__PURE__ */ Object.create(null);\n    this._bufferLayoutsCache = /* @__PURE__ */ Object.create(null);\n    this._bindingNamesCache = /* @__PURE__ */ Object.create(null);\n    this._pipeCache = /* @__PURE__ */ Object.create(null);\n    this._pipeStateCaches = /* @__PURE__ */ Object.create(null);\n    this._colorMask = 15;\n    this._multisampleCount = 1;\n    this._colorTargetCount = 1;\n    this._renderer = renderer;\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n    this.setStencilMode(STENCIL_MODES.DISABLED);\n    this._updatePipeHash();\n  }\n  setMultisampleCount(multisampleCount) {\n    if (this._multisampleCount === multisampleCount)\n      return;\n    this._multisampleCount = multisampleCount;\n    this._updatePipeHash();\n  }\n  setRenderTarget(renderTarget) {\n    this._multisampleCount = renderTarget.msaaSamples;\n    this._depthStencilAttachment = renderTarget.descriptor.depthStencilAttachment ? 1 : 0;\n    this._colorTargetCount = renderTarget.colorTargetCount;\n    this._updatePipeHash();\n  }\n  setColorMask(colorMask) {\n    if (this._colorMask === colorMask)\n      return;\n    this._colorMask = colorMask;\n    this._updatePipeHash();\n  }\n  setStencilMode(stencilMode) {\n    if (this._stencilMode === stencilMode)\n      return;\n    this._stencilMode = stencilMode;\n    this._stencilState = GpuStencilModesToPixi[stencilMode];\n    this._updatePipeHash();\n  }\n  setPipeline(geometry, program, state, passEncoder) {\n    const pipeline = this.getPipeline(geometry, program, state);\n    passEncoder.setPipeline(pipeline);\n  }\n  getPipeline(geometry, program, state, topology) {\n    if (!geometry._layoutKey) {\n      ensureAttributes(geometry, program.attributeData);\n      this._generateBufferKey(geometry);\n    }\n    topology || (topology = geometry.topology);\n    const key = getGraphicsStateKey(\n      geometry._layoutKey,\n      program._layoutKey,\n      state.data,\n      state._blendModeId,\n      topologyStringToId[topology]\n    );\n    if (this._pipeCache[key])\n      return this._pipeCache[key];\n    this._pipeCache[key] = this._createPipeline(geometry, program, state, topology);\n    return this._pipeCache[key];\n  }\n  _createPipeline(geometry, program, state, topology) {\n    const device = this._gpu.device;\n    const buffers = this._createVertexBufferLayouts(geometry, program);\n    const blendModes = this._renderer.state.getColorTargets(state, this._colorTargetCount);\n    const writeMask = this._stencilMode === STENCIL_MODES.RENDERING_MASK_ADD ? 0 : this._colorMask;\n    for (let i = 0; i < blendModes.length; i++) {\n      blendModes[i].writeMask = writeMask;\n    }\n    const layout = this._renderer.shader.getProgramData(program).pipeline;\n    const descriptor = {\n      // TODO later check if its helpful to create..\n      // layout,\n      vertex: {\n        module: this._getModule(program.vertex.source),\n        entryPoint: program.vertex.entryPoint,\n        // geometry..\n        buffers\n      },\n      fragment: {\n        module: this._getModule(program.fragment.source),\n        entryPoint: program.fragment.entryPoint,\n        targets: blendModes\n      },\n      primitive: {\n        topology,\n        cullMode: state.cullMode\n      },\n      layout,\n      multisample: {\n        count: this._multisampleCount\n      },\n      // depthStencil,\n      label: `PIXI Pipeline`\n    };\n    if (this._depthStencilAttachment) {\n      descriptor.depthStencil = {\n        ...this._stencilState,\n        format: \"depth24plus-stencil8\",\n        depthWriteEnabled: state.depthTest,\n        depthCompare: state.depthTest ? \"less\" : \"always\"\n      };\n    }\n    const pipeline = device.createRenderPipeline(descriptor);\n    return pipeline;\n  }\n  _getModule(code) {\n    return this._moduleCache[code] || this._createModule(code);\n  }\n  _createModule(code) {\n    const device = this._gpu.device;\n    this._moduleCache[code] = device.createShaderModule({\n      code\n    });\n    return this._moduleCache[code];\n  }\n  _generateBufferKey(geometry) {\n    const keyGen = [];\n    let index = 0;\n    const attributeKeys = Object.keys(geometry.attributes).sort();\n    for (let i = 0; i < attributeKeys.length; i++) {\n      const attribute = geometry.attributes[attributeKeys[i]];\n      keyGen[index++] = attribute.offset;\n      keyGen[index++] = attribute.format;\n      keyGen[index++] = attribute.stride;\n      keyGen[index++] = attribute.instance;\n    }\n    const stringKey = keyGen.join(\"|\");\n    geometry._layoutKey = createIdFromString(stringKey, \"geometry\");\n    return geometry._layoutKey;\n  }\n  _generateAttributeLocationsKey(program) {\n    const keyGen = [];\n    let index = 0;\n    const attributeKeys = Object.keys(program.attributeData).sort();\n    for (let i = 0; i < attributeKeys.length; i++) {\n      const attribute = program.attributeData[attributeKeys[i]];\n      keyGen[index++] = attribute.location;\n    }\n    const stringKey = keyGen.join(\"|\");\n    program._attributeLocationsKey = createIdFromString(stringKey, \"programAttributes\");\n    return program._attributeLocationsKey;\n  }\n  /**\n   * Returns a hash of buffer names mapped to bind locations.\n   * This is used to bind the correct buffer to the correct location in the shader.\n   * @param geometry - The geometry where to get the buffer names\n   * @param program - The program where to get the buffer names\n   * @returns An object of buffer names mapped to the bind location.\n   */\n  getBufferNamesToBind(geometry, program) {\n    const key = geometry._layoutKey << 16 | program._attributeLocationsKey;\n    if (this._bindingNamesCache[key])\n      return this._bindingNamesCache[key];\n    const data = this._createVertexBufferLayouts(geometry, program);\n    const bufferNamesToBind = /* @__PURE__ */ Object.create(null);\n    const attributeData = program.attributeData;\n    for (let i = 0; i < data.length; i++) {\n      const attributes = Object.values(data[i].attributes);\n      const shaderLocation = attributes[0].shaderLocation;\n      for (const j in attributeData) {\n        if (attributeData[j].location === shaderLocation) {\n          bufferNamesToBind[i] = j;\n          break;\n        }\n      }\n    }\n    this._bindingNamesCache[key] = bufferNamesToBind;\n    return bufferNamesToBind;\n  }\n  _createVertexBufferLayouts(geometry, program) {\n    if (!program._attributeLocationsKey)\n      this._generateAttributeLocationsKey(program);\n    const key = geometry._layoutKey << 16 | program._attributeLocationsKey;\n    if (this._bufferLayoutsCache[key]) {\n      return this._bufferLayoutsCache[key];\n    }\n    const vertexBuffersLayout = [];\n    geometry.buffers.forEach((buffer) => {\n      const bufferEntry = {\n        arrayStride: 0,\n        stepMode: \"vertex\",\n        attributes: []\n      };\n      const bufferEntryAttributes = bufferEntry.attributes;\n      for (const i in program.attributeData) {\n        const attribute = geometry.attributes[i];\n        if ((attribute.divisor ?? 1) !== 1) {\n          warn(`Attribute ${i} has an invalid divisor value of '${attribute.divisor}'. WebGPU only supports a divisor value of 1`);\n        }\n        if (attribute.buffer === buffer) {\n          bufferEntry.arrayStride = attribute.stride;\n          bufferEntry.stepMode = attribute.instance ? \"instance\" : \"vertex\";\n          bufferEntryAttributes.push({\n            shaderLocation: program.attributeData[i].location,\n            offset: attribute.offset,\n            format: attribute.format\n          });\n        }\n      }\n      if (bufferEntryAttributes.length) {\n        vertexBuffersLayout.push(bufferEntry);\n      }\n    });\n    this._bufferLayoutsCache[key] = vertexBuffersLayout;\n    return vertexBuffersLayout;\n  }\n  _updatePipeHash() {\n    const key = getGlobalStateKey(\n      this._stencilMode,\n      this._multisampleCount,\n      this._colorMask,\n      this._depthStencilAttachment,\n      this._colorTargetCount\n    );\n    if (!this._pipeStateCaches[key]) {\n      this._pipeStateCaches[key] = /* @__PURE__ */ Object.create(null);\n    }\n    this._pipeCache = this._pipeStateCaches[key];\n  }\n  destroy() {\n    this._renderer = null;\n    this._bufferLayoutsCache = null;\n  }\n}\n/** @ignore */\nPipelineSystem.extension = {\n  type: [ExtensionType.WebGPUSystem],\n  name: \"pipeline\"\n};\n\nexport { PipelineSystem };\n//# sourceMappingURL=PipelineSystem.mjs.map\n","\"use strict\";\nclass GpuRenderTarget {\n  constructor() {\n    this.contexts = [];\n    this.msaaTextures = [];\n    this.msaaSamples = 1;\n  }\n}\n\nexport { GpuRenderTarget };\n//# sourceMappingURL=GpuRenderTarget.mjs.map\n","import { CLEAR } from '../../gl/const.mjs';\nimport { CanvasSource } from '../../shared/texture/sources/CanvasSource.mjs';\nimport { TextureSource } from '../../shared/texture/sources/TextureSource.mjs';\nimport { GpuRenderTarget } from './GpuRenderTarget.mjs';\n\n\"use strict\";\nclass GpuRenderTargetAdaptor {\n  init(renderer, renderTargetSystem) {\n    this._renderer = renderer;\n    this._renderTargetSystem = renderTargetSystem;\n  }\n  copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {\n    const renderer = this._renderer;\n    const baseGpuTexture = this._getGpuColorTexture(\n      sourceRenderSurfaceTexture\n    );\n    const backGpuTexture = renderer.texture.getGpuSource(\n      destinationTexture.source\n    );\n    renderer.encoder.commandEncoder.copyTextureToTexture(\n      {\n        texture: baseGpuTexture,\n        origin: originSrc\n      },\n      {\n        texture: backGpuTexture,\n        origin: originDest\n      },\n      size\n    );\n    return destinationTexture;\n  }\n  startRenderPass(renderTarget, clear = true, clearColor, viewport) {\n    const renderTargetSystem = this._renderTargetSystem;\n    const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n    const descriptor = this.getDescriptor(renderTarget, clear, clearColor);\n    gpuRenderTarget.descriptor = descriptor;\n    this._renderer.pipeline.setRenderTarget(gpuRenderTarget);\n    this._renderer.encoder.beginRenderPass(gpuRenderTarget);\n    this._renderer.encoder.setViewport(viewport);\n  }\n  finishRenderPass() {\n    this._renderer.encoder.endRenderPass();\n  }\n  /**\n   * returns the gpu texture for the first color texture in the render target\n   * mainly used by the filter manager to get copy the texture for blending\n   * @param renderTarget\n   * @returns a gpu texture\n   */\n  _getGpuColorTexture(renderTarget) {\n    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n    if (gpuRenderTarget.contexts[0]) {\n      return gpuRenderTarget.contexts[0].getCurrentTexture();\n    }\n    return this._renderer.texture.getGpuSource(\n      renderTarget.colorTextures[0].source\n    );\n  }\n  getDescriptor(renderTarget, clear, clearValue) {\n    if (typeof clear === \"boolean\") {\n      clear = clear ? CLEAR.ALL : CLEAR.NONE;\n    }\n    const renderTargetSystem = this._renderTargetSystem;\n    const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n    const colorAttachments = renderTarget.colorTextures.map(\n      (texture, i) => {\n        const context = gpuRenderTarget.contexts[i];\n        let view;\n        let resolveTarget;\n        if (context) {\n          const currentTexture = context.getCurrentTexture();\n          const canvasTextureView = currentTexture.createView();\n          view = canvasTextureView;\n        } else {\n          view = this._renderer.texture.getGpuSource(texture).createView({\n            mipLevelCount: 1\n          });\n        }\n        if (gpuRenderTarget.msaaTextures[i]) {\n          resolveTarget = view;\n          view = this._renderer.texture.getTextureView(\n            gpuRenderTarget.msaaTextures[i]\n          );\n        }\n        const loadOp = clear & CLEAR.COLOR ? \"clear\" : \"load\";\n        clearValue ?? (clearValue = renderTargetSystem.defaultClearColor);\n        return {\n          view,\n          resolveTarget,\n          clearValue,\n          storeOp: \"store\",\n          loadOp\n        };\n      }\n    );\n    let depthStencilAttachment;\n    if ((renderTarget.stencil || renderTarget.depth) && !renderTarget.depthStencilTexture) {\n      renderTarget.ensureDepthStencilTexture();\n      renderTarget.depthStencilTexture.source.sampleCount = gpuRenderTarget.msaa ? 4 : 1;\n    }\n    if (renderTarget.depthStencilTexture) {\n      const stencilLoadOp = clear & CLEAR.STENCIL ? \"clear\" : \"load\";\n      const depthLoadOp = clear & CLEAR.DEPTH ? \"clear\" : \"load\";\n      depthStencilAttachment = {\n        view: this._renderer.texture.getGpuSource(renderTarget.depthStencilTexture.source).createView(),\n        stencilStoreOp: \"store\",\n        stencilLoadOp,\n        depthClearValue: 1,\n        depthLoadOp,\n        depthStoreOp: \"store\"\n      };\n    }\n    const descriptor = {\n      colorAttachments,\n      depthStencilAttachment\n    };\n    return descriptor;\n  }\n  clear(renderTarget, clear = true, clearColor, viewport) {\n    if (!clear)\n      return;\n    const { gpu, encoder } = this._renderer;\n    const device = gpu.device;\n    const standAlone = encoder.commandEncoder === null;\n    if (standAlone) {\n      const commandEncoder = device.createCommandEncoder();\n      const renderPassDescriptor = this.getDescriptor(renderTarget, clear, clearColor);\n      const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n      passEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n      passEncoder.end();\n      const gpuCommands = commandEncoder.finish();\n      device.queue.submit([gpuCommands]);\n    } else {\n      this.startRenderPass(renderTarget, clear, clearColor, viewport);\n    }\n  }\n  initGpuRenderTarget(renderTarget) {\n    renderTarget.isRoot = true;\n    const gpuRenderTarget = new GpuRenderTarget();\n    gpuRenderTarget.colorTargetCount = renderTarget.colorTextures.length;\n    renderTarget.colorTextures.forEach((colorTexture, i) => {\n      if (colorTexture instanceof CanvasSource) {\n        const context = colorTexture.resource.getContext(\n          \"webgpu\"\n        );\n        const alphaMode = colorTexture.transparent ? \"premultiplied\" : \"opaque\";\n        try {\n          context.configure({\n            device: this._renderer.gpu.device,\n            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\n            format: \"bgra8unorm\",\n            alphaMode\n          });\n        } catch (e) {\n          console.error(e);\n        }\n        gpuRenderTarget.contexts[i] = context;\n      }\n      gpuRenderTarget.msaa = colorTexture.source.antialias;\n      if (colorTexture.source.antialias) {\n        const msaaTexture = new TextureSource({\n          width: 0,\n          height: 0,\n          sampleCount: 4\n        });\n        gpuRenderTarget.msaaTextures[i] = msaaTexture;\n      }\n    });\n    if (gpuRenderTarget.msaa) {\n      gpuRenderTarget.msaaSamples = 4;\n      if (renderTarget.depthStencilTexture) {\n        renderTarget.depthStencilTexture.source.sampleCount = 4;\n      }\n    }\n    return gpuRenderTarget;\n  }\n  destroyGpuRenderTarget(gpuRenderTarget) {\n    gpuRenderTarget.contexts.forEach((context) => {\n      context.unconfigure();\n    });\n    gpuRenderTarget.msaaTextures.forEach((texture) => {\n      texture.destroy();\n    });\n    gpuRenderTarget.msaaTextures.length = 0;\n    gpuRenderTarget.contexts.length = 0;\n  }\n  ensureDepthStencilTexture(renderTarget) {\n    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n    if (renderTarget.depthStencilTexture && gpuRenderTarget.msaa) {\n      renderTarget.depthStencilTexture.source.sampleCount = 4;\n    }\n  }\n  resizeGpuRenderTarget(renderTarget) {\n    const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n    gpuRenderTarget.width = renderTarget.width;\n    gpuRenderTarget.height = renderTarget.height;\n    if (gpuRenderTarget.msaa) {\n      renderTarget.colorTextures.forEach((colorTexture, i) => {\n        const msaaTexture = gpuRenderTarget.msaaTextures[i];\n        msaaTexture?.resize(\n          colorTexture.source.width,\n          colorTexture.source.height,\n          colorTexture.source._resolution\n        );\n      });\n    }\n  }\n}\n\nexport { GpuRenderTargetAdaptor };\n//# sourceMappingURL=GpuRenderTargetAdaptor.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem.mjs';\nimport { GpuRenderTargetAdaptor } from './GpuRenderTargetAdaptor.mjs';\n\n\"use strict\";\nclass GpuRenderTargetSystem extends RenderTargetSystem {\n  constructor(renderer) {\n    super(renderer);\n    this.adaptor = new GpuRenderTargetAdaptor();\n    this.adaptor.init(renderer, this);\n  }\n}\n/** @ignore */\nGpuRenderTargetSystem.extension = {\n  type: [ExtensionType.WebGPUSystem],\n  name: \"renderTarget\"\n};\n\nexport { GpuRenderTargetSystem };\n//# sourceMappingURL=GpuRenderTargetSystem.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass GpuShaderSystem {\n  constructor() {\n    this._gpuProgramData = /* @__PURE__ */ Object.create(null);\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n  getProgramData(program) {\n    return this._gpuProgramData[program._layoutKey] || this._createGPUProgramData(program);\n  }\n  _createGPUProgramData(program) {\n    const device = this._gpu.device;\n    const bindGroups = program.gpuLayout.map((group) => device.createBindGroupLayout({ entries: group }));\n    const pipelineLayoutDesc = { bindGroupLayouts: bindGroups };\n    this._gpuProgramData[program._layoutKey] = {\n      bindGroups,\n      pipeline: device.createPipelineLayout(pipelineLayoutDesc)\n    };\n    return this._gpuProgramData[program._layoutKey];\n  }\n  destroy() {\n    this._gpu = null;\n    this._gpuProgramData = null;\n  }\n}\n/** @ignore */\nGpuShaderSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"shader\"\n};\n\nexport { GpuShaderSystem };\n//# sourceMappingURL=GpuShaderSystem.mjs.map\n","\"use strict\";\nconst GpuBlendModesToPixi = {};\nGpuBlendModesToPixi.normal = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.add = {\n  alpha: {\n    srcFactor: \"src-alpha\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"one\",\n    dstFactor: \"one\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.multiply = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"dst\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.screen = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.overlay = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.none = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"zero\",\n    dstFactor: \"zero\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi[\"normal-npm\"] = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"src-alpha\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi[\"add-npm\"] = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"src-alpha\",\n    dstFactor: \"one\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi[\"screen-npm\"] = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"src-alpha\",\n    dstFactor: \"one-minus-src\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.erase = {\n  alpha: {\n    srcFactor: \"zero\",\n    dstFactor: \"one-minus-src-alpha\",\n    operation: \"add\"\n  },\n  color: {\n    srcFactor: \"zero\",\n    dstFactor: \"one-minus-src\",\n    operation: \"add\"\n  }\n};\nGpuBlendModesToPixi.min = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one\",\n    operation: \"min\"\n  },\n  color: {\n    srcFactor: \"one\",\n    dstFactor: \"one\",\n    operation: \"min\"\n  }\n};\nGpuBlendModesToPixi.max = {\n  alpha: {\n    srcFactor: \"one\",\n    dstFactor: \"one\",\n    operation: \"max\"\n  },\n  color: {\n    srcFactor: \"one\",\n    dstFactor: \"one\",\n    operation: \"max\"\n  }\n};\n\nexport { GpuBlendModesToPixi };\n//# sourceMappingURL=GpuBlendModesToPixi.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { State } from '../../shared/state/State.mjs';\nimport { GpuBlendModesToPixi } from './GpuBlendModesToPixi.mjs';\n\n\"use strict\";\nclass GpuStateSystem {\n  constructor() {\n    this.defaultState = new State();\n    this.defaultState.blend = true;\n  }\n  contextChange(gpu) {\n    this.gpu = gpu;\n  }\n  /**\n   * Gets the blend mode data for the current state\n   * @param state - The state to get the blend mode from\n   * @param count - The number of color targets to create\n   */\n  getColorTargets(state, count) {\n    const blend = GpuBlendModesToPixi[state.blendMode] || GpuBlendModesToPixi.normal;\n    const targets = [];\n    const target = {\n      format: \"bgra8unorm\",\n      writeMask: 0,\n      blend\n    };\n    for (let i = 0; i < count; i++) {\n      targets[i] = target;\n    }\n    return targets;\n  }\n  destroy() {\n    this.gpu = null;\n  }\n}\n/** @ignore */\nGpuStateSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"state\"\n};\n\nexport { GpuStateSystem };\n//# sourceMappingURL=GpuStateSystem.mjs.map\n","\"use strict\";\nconst gpuUploadBufferImageResource = {\n  type: \"image\",\n  upload(source, gpuTexture, gpu) {\n    const resource = source.resource;\n    const total = (source.pixelWidth | 0) * (source.pixelHeight | 0);\n    const bytesPerPixel = resource.byteLength / total;\n    gpu.device.queue.writeTexture(\n      { texture: gpuTexture },\n      resource,\n      {\n        offset: 0,\n        rowsPerImage: source.pixelHeight,\n        bytesPerRow: source.pixelWidth * bytesPerPixel\n      },\n      {\n        width: source.pixelWidth,\n        height: source.pixelHeight,\n        depthOrArrayLayers: 1\n      }\n    );\n  }\n};\n\nexport { gpuUploadBufferImageResource };\n//# sourceMappingURL=gpuUploadBufferImageResource.mjs.map\n","\"use strict\";\nconst blockDataMap = {\n  \"bc1-rgba-unorm\": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },\n  \"bc2-rgba-unorm\": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n  \"bc3-rgba-unorm\": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n  \"bc7-rgba-unorm\": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n  \"etc1-rgb-unorm\": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },\n  \"etc2-rgba8unorm\": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n  \"astc-4x4-unorm\": { blockBytes: 16, blockWidth: 4, blockHeight: 4 }\n};\nconst defaultBlockData = { blockBytes: 4, blockWidth: 1, blockHeight: 1 };\nconst gpuUploadCompressedTextureResource = {\n  type: \"compressed\",\n  upload(source, gpuTexture, gpu) {\n    let mipWidth = source.pixelWidth;\n    let mipHeight = source.pixelHeight;\n    const blockData = blockDataMap[source.format] || defaultBlockData;\n    for (let i = 0; i < source.resource.length; i++) {\n      const levelBuffer = source.resource[i];\n      const bytesPerRow = Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockBytes;\n      gpu.device.queue.writeTexture(\n        {\n          texture: gpuTexture,\n          mipLevel: i\n        },\n        levelBuffer,\n        {\n          offset: 0,\n          bytesPerRow\n        },\n        {\n          width: Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockWidth,\n          height: Math.ceil(mipHeight / blockData.blockHeight) * blockData.blockHeight,\n          depthOrArrayLayers: 1\n        }\n      );\n      mipWidth = Math.max(mipWidth >> 1, 1);\n      mipHeight = Math.max(mipHeight >> 1, 1);\n    }\n  }\n};\n\nexport { blockDataMap, gpuUploadCompressedTextureResource };\n//# sourceMappingURL=gpuUploadCompressedTextureResource.mjs.map\n","import { DOMAdapter } from '../../../../../environment/adapter.mjs';\nimport { warn } from '../../../../../utils/logging/warn.mjs';\n\n\"use strict\";\nconst gpuUploadImageResource = {\n  type: \"image\",\n  upload(source, gpuTexture, gpu) {\n    const resource = source.resource;\n    if (!resource)\n      return;\n    if (globalThis.HTMLImageElement && resource instanceof HTMLImageElement) {\n      const canvas = DOMAdapter.get().createCanvas(resource.width, resource.height);\n      const context = canvas.getContext(\"2d\");\n      context.drawImage(resource, 0, 0, resource.width, resource.height);\n      source.resource = canvas;\n      warn(\"ImageSource: Image element passed, converting to canvas and replacing resource.\");\n    }\n    const width = Math.min(gpuTexture.width, source.resourceWidth || source.pixelWidth);\n    const height = Math.min(gpuTexture.height, source.resourceHeight || source.pixelHeight);\n    const premultipliedAlpha = source.alphaMode === \"premultiply-alpha-on-upload\";\n    gpu.device.queue.copyExternalImageToTexture(\n      { source: resource },\n      { texture: gpuTexture, premultipliedAlpha },\n      {\n        width,\n        height\n      }\n    );\n  }\n};\n\nexport { gpuUploadImageResource };\n//# sourceMappingURL=gpuUploadImageSource.mjs.map\n","import { gpuUploadImageResource } from './gpuUploadImageSource.mjs';\n\n\"use strict\";\nconst gpuUploadVideoResource = {\n  type: \"video\",\n  upload(source, gpuTexture, gpu) {\n    gpuUploadImageResource.upload(source, gpuTexture, gpu);\n  }\n};\n\nexport { gpuUploadVideoResource };\n//# sourceMappingURL=gpuUploadVideoSource.mjs.map\n","\"use strict\";\nclass GpuMipmapGenerator {\n  constructor(device) {\n    this.device = device;\n    this.sampler = device.createSampler({ minFilter: \"linear\" });\n    this.pipelines = {};\n  }\n  _getMipmapPipeline(format) {\n    let pipeline = this.pipelines[format];\n    if (!pipeline) {\n      if (!this.mipmapShaderModule) {\n        this.mipmapShaderModule = this.device.createShaderModule({\n          code: (\n            /* wgsl */\n            `\n                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));\n\n                        struct VertexOutput {\n                        @builtin(position) position : vec4<f32>,\n                        @location(0) texCoord : vec2<f32>,\n                        };\n\n                        @vertex\n                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n                        var output : VertexOutput;\n                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);\n                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);\n                        return output;\n                        }\n\n                        @group(0) @binding(0) var imgSampler : sampler;\n                        @group(0) @binding(1) var img : texture_2d<f32>;\n\n                        @fragment\n                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {\n                        return textureSample(img, imgSampler, texCoord);\n                        }\n                    `\n          )\n        });\n      }\n      pipeline = this.device.createRenderPipeline({\n        layout: \"auto\",\n        vertex: {\n          module: this.mipmapShaderModule,\n          entryPoint: \"vertexMain\"\n        },\n        fragment: {\n          module: this.mipmapShaderModule,\n          entryPoint: \"fragmentMain\",\n          targets: [{ format }]\n        }\n      });\n      this.pipelines[format] = pipeline;\n    }\n    return pipeline;\n  }\n  /**\n   * Generates mipmaps for the given GPUTexture from the data in level 0.\n   * @param {module:External.GPUTexture} texture - Texture to generate mipmaps for.\n   * @returns {module:External.GPUTexture} - The originally passed texture\n   */\n  generateMipmap(texture) {\n    const pipeline = this._getMipmapPipeline(texture.format);\n    if (texture.dimension === \"3d\" || texture.dimension === \"1d\") {\n      throw new Error(\"Generating mipmaps for non-2d textures is currently unsupported!\");\n    }\n    let mipTexture = texture;\n    const arrayLayerCount = texture.depthOrArrayLayers || 1;\n    const renderToSource = texture.usage & GPUTextureUsage.RENDER_ATTACHMENT;\n    if (!renderToSource) {\n      const mipTextureDescriptor = {\n        size: {\n          width: Math.ceil(texture.width / 2),\n          height: Math.ceil(texture.height / 2),\n          depthOrArrayLayers: arrayLayerCount\n        },\n        format: texture.format,\n        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n        mipLevelCount: texture.mipLevelCount - 1\n      };\n      mipTexture = this.device.createTexture(mipTextureDescriptor);\n    }\n    const commandEncoder = this.device.createCommandEncoder({});\n    const bindGroupLayout = pipeline.getBindGroupLayout(0);\n    for (let arrayLayer = 0; arrayLayer < arrayLayerCount; ++arrayLayer) {\n      let srcView = texture.createView({\n        baseMipLevel: 0,\n        mipLevelCount: 1,\n        dimension: \"2d\",\n        baseArrayLayer: arrayLayer,\n        arrayLayerCount: 1\n      });\n      let dstMipLevel = renderToSource ? 1 : 0;\n      for (let i = 1; i < texture.mipLevelCount; ++i) {\n        const dstView = mipTexture.createView({\n          baseMipLevel: dstMipLevel++,\n          mipLevelCount: 1,\n          dimension: \"2d\",\n          baseArrayLayer: arrayLayer,\n          arrayLayerCount: 1\n        });\n        const passEncoder = commandEncoder.beginRenderPass({\n          colorAttachments: [{\n            view: dstView,\n            storeOp: \"store\",\n            loadOp: \"clear\",\n            clearValue: { r: 0, g: 0, b: 0, a: 0 }\n          }]\n        });\n        const bindGroup = this.device.createBindGroup({\n          layout: bindGroupLayout,\n          entries: [{\n            binding: 0,\n            resource: this.sampler\n          }, {\n            binding: 1,\n            resource: srcView\n          }]\n        });\n        passEncoder.setPipeline(pipeline);\n        passEncoder.setBindGroup(0, bindGroup);\n        passEncoder.draw(3, 1, 0, 0);\n        passEncoder.end();\n        srcView = dstView;\n      }\n    }\n    if (!renderToSource) {\n      const mipLevelSize = {\n        width: Math.ceil(texture.width / 2),\n        height: Math.ceil(texture.height / 2),\n        depthOrArrayLayers: arrayLayerCount\n      };\n      for (let i = 1; i < texture.mipLevelCount; ++i) {\n        commandEncoder.copyTextureToTexture({\n          texture: mipTexture,\n          mipLevel: i - 1\n        }, {\n          texture,\n          mipLevel: i\n        }, mipLevelSize);\n        mipLevelSize.width = Math.ceil(mipLevelSize.width / 2);\n        mipLevelSize.height = Math.ceil(mipLevelSize.height / 2);\n      }\n    }\n    this.device.queue.submit([commandEncoder.finish()]);\n    if (!renderToSource) {\n      mipTexture.destroy();\n    }\n    return texture;\n  }\n}\n\nexport { GpuMipmapGenerator };\n//# sourceMappingURL=GpuMipmapGenerator.mjs.map\n","import { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { GCManagedHash } from '../../../../utils/data/GCManagedHash.mjs';\nimport { UniformGroup } from '../../shared/shader/UniformGroup.mjs';\nimport { CanvasPool } from '../../shared/texture/CanvasPool.mjs';\nimport { BindGroup } from '../shader/BindGroup.mjs';\nimport { gpuUploadBufferImageResource } from './uploaders/gpuUploadBufferImageResource.mjs';\nimport { gpuUploadCompressedTextureResource, blockDataMap } from './uploaders/gpuUploadCompressedTextureResource.mjs';\nimport { gpuUploadImageResource } from './uploaders/gpuUploadImageSource.mjs';\nimport { gpuUploadVideoResource } from './uploaders/gpuUploadVideoSource.mjs';\nimport { GpuMipmapGenerator } from './utils/GpuMipmapGenerator.mjs';\n\n\"use strict\";\nclass GPUTextureGpuData {\n  constructor(gpuTexture) {\n    this.textureView = null;\n    this.gpuTexture = gpuTexture;\n  }\n  /** Destroys this GPU data instance. */\n  destroy() {\n    this.gpuTexture.destroy();\n    this.textureView = null;\n    this.gpuTexture = null;\n  }\n}\nclass GpuTextureSystem {\n  constructor(renderer) {\n    this._gpuSamplers = /* @__PURE__ */ Object.create(null);\n    this._bindGroupHash = /* @__PURE__ */ Object.create(null);\n    this._uploads = {\n      image: gpuUploadImageResource,\n      buffer: gpuUploadBufferImageResource,\n      video: gpuUploadVideoResource,\n      compressed: gpuUploadCompressedTextureResource\n    };\n    this._renderer = renderer;\n    renderer.renderableGC.addManagedHash(this, \"_bindGroupHash\");\n    this._managedTextures = new GCManagedHash({\n      renderer,\n      type: \"resource\",\n      onUnload: this.onSourceUnload.bind(this),\n      name: \"gpuTextureSource\"\n    });\n  }\n  /**\n   * @deprecated since 8.15.0\n   */\n  get managedTextures() {\n    return Object.values(this._managedTextures.items);\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n  }\n  /**\n   * Initializes a texture source, if it has already been initialized nothing will happen.\n   * @param source - The texture source to initialize.\n   * @returns The initialized texture source.\n   */\n  initSource(source) {\n    return source._gpuData[this._renderer.uid]?.gpuTexture || this._initSource(source);\n  }\n  _initSource(source) {\n    if (source.autoGenerateMipmaps) {\n      const biggestDimension = Math.max(source.pixelWidth, source.pixelHeight);\n      source.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;\n    }\n    let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;\n    if (source.uploadMethodId !== \"compressed\") {\n      usage |= GPUTextureUsage.RENDER_ATTACHMENT;\n      usage |= GPUTextureUsage.COPY_SRC;\n    }\n    const blockData = blockDataMap[source.format] || { blockBytes: 4, blockWidth: 1, blockHeight: 1 };\n    const width = Math.ceil(source.pixelWidth / blockData.blockWidth) * blockData.blockWidth;\n    const height = Math.ceil(source.pixelHeight / blockData.blockHeight) * blockData.blockHeight;\n    const textureDescriptor = {\n      label: source.label,\n      size: { width, height },\n      format: source.format,\n      sampleCount: source.sampleCount,\n      mipLevelCount: source.mipLevelCount,\n      dimension: source.dimension,\n      usage\n    };\n    const gpuTexture = this._gpu.device.createTexture(textureDescriptor);\n    source._gpuData[this._renderer.uid] = new GPUTextureGpuData(gpuTexture);\n    const added = this._managedTextures.add(source);\n    if (added) {\n      source.on(\"update\", this.onSourceUpdate, this);\n      source.on(\"resize\", this.onSourceResize, this);\n      source.on(\"updateMipmaps\", this.onUpdateMipmaps, this);\n    }\n    this.onSourceUpdate(source);\n    return gpuTexture;\n  }\n  onSourceUpdate(source) {\n    const gpuTexture = this.getGpuSource(source);\n    if (!gpuTexture)\n      return;\n    if (this._uploads[source.uploadMethodId]) {\n      this._uploads[source.uploadMethodId].upload(source, gpuTexture, this._gpu);\n    }\n    if (source.autoGenerateMipmaps && source.mipLevelCount > 1) {\n      this.onUpdateMipmaps(source);\n    }\n  }\n  onUpdateMipmaps(source) {\n    if (!this._mipmapGenerator) {\n      this._mipmapGenerator = new GpuMipmapGenerator(this._gpu.device);\n    }\n    const gpuTexture = this.getGpuSource(source);\n    this._mipmapGenerator.generateMipmap(gpuTexture);\n  }\n  onSourceUnload(source) {\n    source.off(\"update\", this.onSourceUpdate, this);\n    source.off(\"resize\", this.onSourceResize, this);\n    source.off(\"updateMipmaps\", this.onUpdateMipmaps, this);\n  }\n  onSourceResize(source) {\n    source._gcLastUsed = this._renderer.gc.now;\n    const gpuData = source._gpuData[this._renderer.uid];\n    const gpuTexture = gpuData?.gpuTexture;\n    if (!gpuTexture) {\n      this.initSource(source);\n    } else if (gpuTexture.width !== source.pixelWidth || gpuTexture.height !== source.pixelHeight) {\n      gpuData.destroy();\n      this._bindGroupHash[source.uid] = null;\n      source._gpuData[this._renderer.uid] = null;\n      this.initSource(source);\n    }\n  }\n  _initSampler(sampler) {\n    this._gpuSamplers[sampler._resourceId] = this._gpu.device.createSampler(sampler);\n    return this._gpuSamplers[sampler._resourceId];\n  }\n  getGpuSampler(sampler) {\n    return this._gpuSamplers[sampler._resourceId] || this._initSampler(sampler);\n  }\n  getGpuSource(source) {\n    source._gcLastUsed = this._renderer.gc.now;\n    return source._gpuData[this._renderer.uid]?.gpuTexture || this.initSource(source);\n  }\n  /**\n   * this returns s bind group for a specific texture, the bind group contains\n   * - the texture source\n   * - the texture style\n   * - the texture matrix\n   * This is cached so the bind group should only be created once per texture\n   * @param texture - the texture you want the bindgroup for\n   * @returns the bind group for the texture\n   */\n  getTextureBindGroup(texture) {\n    return this._bindGroupHash[texture.uid] || this._createTextureBindGroup(texture);\n  }\n  _createTextureBindGroup(texture) {\n    const source = texture.source;\n    this._bindGroupHash[texture.uid] = new BindGroup({\n      0: source,\n      1: source.style,\n      2: new UniformGroup({\n        uTextureMatrix: { type: \"mat3x3<f32>\", value: texture.textureMatrix.mapCoord }\n      })\n    });\n    return this._bindGroupHash[texture.uid];\n  }\n  getTextureView(texture) {\n    const source = texture.source;\n    source._gcLastUsed = this._renderer.gc.now;\n    let gpuData = source._gpuData[this._renderer.uid];\n    let textureView = null;\n    if (!gpuData) {\n      this.initSource(source);\n      gpuData = source._gpuData[this._renderer.uid];\n    }\n    textureView = gpuData.textureView || gpuData.gpuTexture.createView();\n    return textureView;\n  }\n  generateCanvas(texture) {\n    const renderer = this._renderer;\n    const commandEncoder = renderer.gpu.device.createCommandEncoder();\n    const canvas = DOMAdapter.get().createCanvas();\n    canvas.width = texture.source.pixelWidth;\n    canvas.height = texture.source.pixelHeight;\n    const context = canvas.getContext(\"webgpu\");\n    context.configure({\n      device: renderer.gpu.device,\n      usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,\n      format: DOMAdapter.get().getNavigator().gpu.getPreferredCanvasFormat(),\n      alphaMode: \"premultiplied\"\n    });\n    commandEncoder.copyTextureToTexture({\n      texture: renderer.texture.getGpuSource(texture.source),\n      origin: {\n        x: 0,\n        y: 0\n      }\n    }, {\n      texture: context.getCurrentTexture()\n    }, {\n      width: canvas.width,\n      height: canvas.height\n    });\n    renderer.gpu.device.queue.submit([commandEncoder.finish()]);\n    return canvas;\n  }\n  getPixels(texture) {\n    const webGPUCanvas = this.generateCanvas(texture);\n    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(webGPUCanvas.width, webGPUCanvas.height);\n    const context = canvasAndContext.context;\n    context.drawImage(webGPUCanvas, 0, 0);\n    const { width, height } = webGPUCanvas;\n    const imageData = context.getImageData(0, 0, width, height);\n    const pixels = new Uint8ClampedArray(imageData.data.buffer);\n    CanvasPool.returnCanvasAndContext(canvasAndContext);\n    return { pixels, width, height };\n  }\n  destroy() {\n    this._managedTextures.destroy();\n    for (const k of Object.keys(this._bindGroupHash)) {\n      const key = Number(k);\n      const bindGroup = this._bindGroupHash[key];\n      bindGroup?.destroy();\n    }\n    this._renderer = null;\n    this._gpu = null;\n    this._mipmapGenerator = null;\n    this._gpuSamplers = null;\n    this._bindGroupHash = null;\n  }\n}\n/** @ignore */\nGpuTextureSystem.extension = {\n  type: [\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"texture\"\n};\n\nexport { GPUTextureGpuData, GpuTextureSystem };\n//# sourceMappingURL=GpuTextureSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { getTextureBatchBindGroup } from '../../../rendering/batcher/gpu/getTextureBatchBindGroup.mjs';\nimport { compileHighShaderGpuProgram } from '../../../rendering/high-shader/compileHighShaderToProgram.mjs';\nimport { colorBit } from '../../../rendering/high-shader/shader-bits/colorBit.mjs';\nimport { generateTextureBatchBit } from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit.mjs';\nimport { localUniformBitGroup2 } from '../../../rendering/high-shader/shader-bits/localUniformBit.mjs';\nimport { roundPixelsBit } from '../../../rendering/high-shader/shader-bits/roundPixelsBit.mjs';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\n\n\"use strict\";\nclass GpuGraphicsAdaptor {\n  constructor() {\n    this._maxTextures = 0;\n  }\n  contextChange(renderer) {\n    const localUniforms = new UniformGroup({\n      uTransformMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uColor: { value: new Float32Array([1, 1, 1, 1]), type: \"vec4<f32>\" },\n      uRound: { value: 0, type: \"f32\" }\n    });\n    this._maxTextures = renderer.limits.maxBatchableTextures;\n    const gpuProgram = compileHighShaderGpuProgram({\n      name: \"graphics\",\n      bits: [\n        colorBit,\n        generateTextureBatchBit(this._maxTextures),\n        localUniformBitGroup2,\n        roundPixelsBit\n      ]\n    });\n    this.shader = new Shader({\n      gpuProgram,\n      resources: {\n        // added on the fly!\n        localUniforms\n      }\n    });\n  }\n  execute(graphicsPipe, renderable) {\n    const context = renderable.context;\n    const shader = context.customShader || this.shader;\n    const renderer = graphicsPipe.renderer;\n    const contextSystem = renderer.graphicsContext;\n    const {\n      batcher,\n      instructions\n    } = contextSystem.getContextRenderData(context);\n    const encoder = renderer.encoder;\n    encoder.setGeometry(batcher.geometry, shader.gpuProgram);\n    const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n    encoder.setBindGroup(0, globalUniformsBindGroup, shader.gpuProgram);\n    const localBindGroup = renderer.renderPipes.uniformBatch.getUniformBindGroup(shader.resources.localUniforms, true);\n    encoder.setBindGroup(2, localBindGroup, shader.gpuProgram);\n    const batches = instructions.instructions;\n    let topology = null;\n    for (let i = 0; i < instructions.instructionSize; i++) {\n      const batch = batches[i];\n      if (batch.topology !== topology) {\n        topology = batch.topology;\n        encoder.setPipelineFromGeometryProgramAndState(\n          batcher.geometry,\n          shader.gpuProgram,\n          graphicsPipe.state,\n          batch.topology\n        );\n      }\n      shader.groups[1] = batch.bindGroup;\n      if (!batch.gpuBindGroup) {\n        const textureBatch = batch.textures;\n        batch.bindGroup = getTextureBatchBindGroup(\n          textureBatch.textures,\n          textureBatch.count,\n          this._maxTextures\n        );\n        batch.gpuBindGroup = renderer.bindGroup.getBindGroup(\n          batch.bindGroup,\n          shader.gpuProgram,\n          1\n        );\n      }\n      encoder.setBindGroup(1, batch.bindGroup, shader.gpuProgram);\n      encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n    }\n  }\n  destroy() {\n    this.shader.destroy(true);\n    this.shader = null;\n  }\n}\n/** @ignore */\nGpuGraphicsAdaptor.extension = {\n  type: [\n    ExtensionType.WebGPUPipesAdaptor\n  ],\n  name: \"graphics\"\n};\n\nexport { GpuGraphicsAdaptor };\n//# sourceMappingURL=GpuGraphicsAdaptor.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { compileHighShaderGpuProgram } from '../../../rendering/high-shader/compileHighShaderToProgram.mjs';\nimport { localUniformBit } from '../../../rendering/high-shader/shader-bits/localUniformBit.mjs';\nimport { roundPixelsBit } from '../../../rendering/high-shader/shader-bits/roundPixelsBit.mjs';\nimport { textureBit } from '../../../rendering/high-shader/shader-bits/textureBit.mjs';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader.mjs';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { warn } from '../../../utils/logging/warn.mjs';\n\n\"use strict\";\nclass GpuMeshAdapter {\n  init() {\n    const gpuProgram = compileHighShaderGpuProgram({\n      name: \"mesh\",\n      bits: [\n        localUniformBit,\n        textureBit,\n        roundPixelsBit\n      ]\n    });\n    this._shader = new Shader({\n      gpuProgram,\n      resources: {\n        uTexture: Texture.EMPTY._source,\n        uSampler: Texture.EMPTY._source.style,\n        textureUniforms: {\n          uTextureMatrix: { type: \"mat3x3<f32>\", value: new Matrix() }\n        }\n      }\n    });\n  }\n  execute(meshPipe, mesh) {\n    const renderer = meshPipe.renderer;\n    let shader = mesh._shader;\n    if (!shader) {\n      shader = this._shader;\n      shader.groups[2] = renderer.texture.getTextureBindGroup(mesh.texture);\n    } else if (!shader.gpuProgram) {\n      warn(\"Mesh shader has no gpuProgram\", mesh.shader);\n      return;\n    }\n    const gpuProgram = shader.gpuProgram;\n    if (gpuProgram.autoAssignGlobalUniforms) {\n      shader.groups[0] = renderer.globalUniforms.bindGroup;\n    }\n    if (gpuProgram.autoAssignLocalUniforms) {\n      const localUniforms = meshPipe.localUniforms;\n      shader.groups[1] = renderer.renderPipes.uniformBatch.getUniformBindGroup(localUniforms, true);\n    }\n    renderer.encoder.draw({\n      geometry: mesh._geometry,\n      shader,\n      state: mesh.state\n    });\n  }\n  destroy() {\n    this._shader.destroy(true);\n    this._shader = null;\n  }\n}\n/** @ignore */\nGpuMeshAdapter.extension = {\n  type: [\n    ExtensionType.WebGPUPipesAdaptor\n  ],\n  name: \"mesh\"\n};\n\nexport { GpuMeshAdapter };\n//# sourceMappingURL=GpuMeshAdapter.mjs.map\n","import { extensions, ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { GpuGraphicsAdaptor } from '../../../scene/graphics/gpu/GpuGraphicsAdaptor.mjs';\nimport { GpuMeshAdapter } from '../../../scene/mesh/gpu/GpuMeshAdapter.mjs';\nimport { GpuBatchAdaptor } from '../../batcher/gpu/GpuBatchAdaptor.mjs';\nimport { AbstractRenderer } from '../shared/system/AbstractRenderer.mjs';\nimport { SharedSystems, SharedRenderPipes } from '../shared/system/SharedSystems.mjs';\nimport { RendererType } from '../types.mjs';\nimport { BindGroupSystem } from './BindGroupSystem.mjs';\nimport { GpuBufferSystem } from './buffer/GpuBufferSystem.mjs';\nimport { GpuColorMaskSystem } from './GpuColorMaskSystem.mjs';\nimport { GpuDeviceSystem } from './GpuDeviceSystem.mjs';\nimport { GpuEncoderSystem } from './GpuEncoderSystem.mjs';\nimport { GpuLimitsSystem } from './GpuLimitsSystem.mjs';\nimport { GpuStencilSystem } from './GpuStencilSystem.mjs';\nimport { GpuUboSystem } from './GpuUboSystem.mjs';\nimport { GpuUniformBatchPipe } from './GpuUniformBatchPipe.mjs';\nimport { PipelineSystem } from './pipeline/PipelineSystem.mjs';\nimport { GpuRenderTargetSystem } from './renderTarget/GpuRenderTargetSystem.mjs';\nimport { GpuShaderSystem } from './shader/GpuShaderSystem.mjs';\nimport { GpuStateSystem } from './state/GpuStateSystem.mjs';\nimport { GpuTextureSystem } from './texture/GpuTextureSystem.mjs';\n\n\"use strict\";\nconst DefaultWebGPUSystems = [\n  ...SharedSystems,\n  GpuUboSystem,\n  GpuEncoderSystem,\n  GpuDeviceSystem,\n  GpuLimitsSystem,\n  GpuBufferSystem,\n  GpuTextureSystem,\n  GpuRenderTargetSystem,\n  GpuShaderSystem,\n  GpuStateSystem,\n  PipelineSystem,\n  GpuColorMaskSystem,\n  GpuStencilSystem,\n  BindGroupSystem\n];\nconst DefaultWebGPUPipes = [...SharedRenderPipes, GpuUniformBatchPipe];\nconst DefaultWebGPUAdapters = [GpuBatchAdaptor, GpuMeshAdapter, GpuGraphicsAdaptor];\nconst systems = [];\nconst renderPipes = [];\nconst renderPipeAdaptors = [];\nextensions.handleByNamedList(ExtensionType.WebGPUSystem, systems);\nextensions.handleByNamedList(ExtensionType.WebGPUPipes, renderPipes);\nextensions.handleByNamedList(ExtensionType.WebGPUPipesAdaptor, renderPipeAdaptors);\nextensions.add(...DefaultWebGPUSystems, ...DefaultWebGPUPipes, ...DefaultWebGPUAdapters);\nclass WebGPURenderer extends AbstractRenderer {\n  constructor() {\n    const systemConfig = {\n      name: \"webgpu\",\n      type: RendererType.WEBGPU,\n      systems,\n      renderPipes,\n      renderPipeAdaptors\n    };\n    super(systemConfig);\n  }\n}\n\nexport { WebGPURenderer };\n//# sourceMappingURL=WebGPURenderer.mjs.map\n"],"names":["tempState","State","GpuBatchAdaptor","batchPipe","geometry","shader","renderer","encoder","program","globalUniformsBindGroup","batch","textureBatch","getTextureBatchBindGroup","gpuBindGroup","pipeline","ExtensionType","BindGroupSystem","gpu","bindGroup","groupIndex","group","device","groupLayout","entries","j","resource","gpuResource","uniformGroup","buffer","bufferResource","sampler","texture","layout","GpuBufferData","gpuBuffer","GpuBufferSystem","GCManagedHash","data","uid","fastCopy","UboBatch","minUniformOffsetAlignment","size","start","newSize","array","offset","i","GpuColorMaskSystem","colorMask","GpuDeviceSystem","options","adapter","DOMAdapter","requiredFeatures","feature","GpuEncoderSystem","resolve","gpuRenderTarget","viewport","state","topology","index","indexFormat","buffersToBind","skipSync","instanceCount","descriptor","boundPipeline","boundVertexBuffer","boundIndexBuffer","boundBindGroup","GpuLimitsSystem","GpuStencilSystem","renderTarget","stencilState","STENCIL_MODES","stencilMode","stencilReference","WGSL_ALIGN_SIZE_DATA","createUboElementsWGSL","uniformData","uboElements","uboElement","align","generateArraySyncWGSL","offsetToAdd","remainder","createUboSyncFunctionWGSL","createUboSyncFunction","uboSyncFunctionsWGSL","GpuUboSystem","UboSystem","GpuUniformBatchPipe","totalBuffers","usage","BufferUsage","Buffer","duplicate","BufferResource","BindGroup","bufferSystem","firstBuffer","commandEncoder","topologyStringToId","getGraphicsStateKey","geometryLayout","shaderKey","blendMode","getGlobalStateKey","stencilStateId","multiSampleCount","colorTargetCount","PipelineSystem","multisampleCount","GpuStencilModesToPixi","passEncoder","ensureAttributes","key","buffers","blendModes","writeMask","code","keyGen","attributeKeys","attribute","stringKey","createIdFromString","bufferNamesToBind","attributeData","shaderLocation","vertexBuffersLayout","bufferEntry","bufferEntryAttributes","warn","GpuRenderTarget","GpuRenderTargetAdaptor","renderTargetSystem","sourceRenderSurfaceTexture","destinationTexture","originSrc","originDest","baseGpuTexture","backGpuTexture","clear","clearColor","clearValue","CLEAR","colorAttachments","context","view","resolveTarget","loadOp","depthStencilAttachment","stencilLoadOp","depthLoadOp","renderPassDescriptor","gpuCommands","colorTexture","CanvasSource","alphaMode","e","msaaTexture","TextureSource","GpuRenderTargetSystem","RenderTargetSystem","GpuShaderSystem","bindGroups","pipelineLayoutDesc","GpuBlendModesToPixi","GpuStateSystem","count","blend","targets","target","gpuUploadBufferImageResource","source","gpuTexture","total","bytesPerPixel","blockDataMap","defaultBlockData","gpuUploadCompressedTextureResource","mipWidth","mipHeight","blockData","levelBuffer","bytesPerRow","gpuUploadImageResource","canvas","width","height","premultipliedAlpha","gpuUploadVideoResource","GpuMipmapGenerator","format","mipTexture","arrayLayerCount","renderToSource","mipTextureDescriptor","bindGroupLayout","arrayLayer","srcView","dstMipLevel","dstView","mipLevelSize","GPUTextureGpuData","GpuTextureSystem","biggestDimension","textureDescriptor","gpuData","UniformGroup","textureView","webGPUCanvas","canvasAndContext","CanvasPool","imageData","pixels","k","GpuGraphicsAdaptor","localUniforms","Matrix","gpuProgram","compileHighShaderGpuProgram","colorBit","generateTextureBatchBit","localUniformBitGroup2","roundPixelsBit","Shader","graphicsPipe","renderable","contextSystem","batcher","instructions","localBindGroup","batches","GpuMeshAdapter","localUniformBit","textureBit","Texture","meshPipe","mesh","DefaultWebGPUSystems","SharedSystems","DefaultWebGPUPipes","SharedRenderPipes","DefaultWebGPUAdapters","systems","renderPipes","renderPipeAdaptors","extensions","WebGPURenderer","AbstractRenderer","systemConfig","RendererType"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29]}