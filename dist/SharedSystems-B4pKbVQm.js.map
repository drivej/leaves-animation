{"version":3,"file":"SharedSystems-B4pKbVQm.js","sources":["../node_modules/pixi.js/lib/filters/mask/mask.frag.mjs","../node_modules/pixi.js/lib/filters/mask/mask.vert.mjs","../node_modules/pixi.js/lib/filters/mask/mask.wgsl.mjs","../node_modules/pixi.js/lib/filters/mask/MaskFilter.mjs","../node_modules/pixi.js/lib/rendering/batcher/shared/BatcherPipe.mjs","../node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.mjs","../node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMaskPipe.mjs","../node_modules/pixi.js/lib/rendering/mask/color/ColorMaskPipe.mjs","../node_modules/pixi.js/lib/rendering/mask/stencil/StencilMaskPipe.mjs","../node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensureAttributes.mjs","../node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs","../node_modules/pixi.js/lib/rendering/renderers/shared/shader/UboSystem.mjs","../node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformParsers.mjs","../node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.mjs","../node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.mjs","../node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/calculateProjection.mjs","../node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs","../node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs","../node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs","../node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs","../node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.mjs","../node_modules/pixi.js/lib/scene/container/CustomRenderPipe.mjs","../node_modules/pixi.js/lib/scene/container/utils/executeInstructions.mjs","../node_modules/pixi.js/lib/scene/container/RenderGroupPipe.mjs","../node_modules/pixi.js/lib/scene/container/utils/clearList.mjs","../node_modules/pixi.js/lib/scene/container/utils/updateRenderGroupTransforms.mjs","../node_modules/pixi.js/lib/scene/container/utils/validateRenderables.mjs","../node_modules/pixi.js/lib/scene/container/RenderGroupSystem.mjs","../node_modules/pixi.js/lib/scene/sprite/SpritePipe.mjs","../node_modules/pixi.js/lib/rendering/renderers/shared/background/BackgroundSystem.mjs","../node_modules/pixi.js/lib/rendering/renderers/shared/blendModes/BlendModePipe.mjs","../node_modules/pixi.js/lib/rendering/renderers/shared/extract/ExtractSystem.mjs","../node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderTexture.mjs","../node_modules/pixi.js/lib/rendering/renderers/shared/extract/GenerateTextureSystem.mjs","../node_modules/pixi.js/lib/rendering/renderers/shared/GCSystem.mjs","../node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs","../node_modules/pixi.js/lib/rendering/renderers/shared/SchedulerSystem.mjs","../node_modules/pixi.js/lib/utils/sayHello.mjs","../node_modules/pixi.js/lib/rendering/renderers/shared/startup/HelloSystem.mjs","../node_modules/pixi.js/lib/utils/data/clean.mjs","../node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderableGCSystem.mjs","../node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureGCSystem.mjs","../node_modules/pixi.js/lib/rendering/renderers/shared/view/ViewSystem.mjs","../node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.mjs"],"sourcesContent":["var fragment = \"in vec2 vMaskCoord;\\nin vec2 vTextureCoord;\\n\\nuniform sampler2D uTexture;\\nuniform sampler2D uMaskTexture;\\n\\nuniform float uAlpha;\\nuniform vec4 uMaskClamp;\\nuniform float uInverse;\\n\\nout vec4 finalColor;\\n\\nvoid main(void)\\n{\\n    float clip = step(3.5,\\n        step(uMaskClamp.x, vMaskCoord.x) +\\n        step(uMaskClamp.y, vMaskCoord.y) +\\n        step(vMaskCoord.x, uMaskClamp.z) +\\n        step(vMaskCoord.y, uMaskClamp.w));\\n\\n    // TODO look into why this is needed\\n    float npmAlpha = uAlpha;\\n    vec4 original = texture(uTexture, vTextureCoord);\\n    vec4 masky = texture(uMaskTexture, vMaskCoord);\\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\\n\\n    float a = alphaMul * masky.r * npmAlpha * clip;\\n\\n    if (uInverse == 1.0) {\\n        a = 1.0 - a;\\n    }\\n\\n    finalColor = original * a;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=mask.frag.mjs.map\n","var vertex = \"in vec2 aPosition;\\n\\nout vec2 vTextureCoord;\\nout vec2 vMaskCoord;\\n\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uOutputFrame;\\nuniform vec4 uOutputTexture;\\nuniform mat3 uFilterMatrix;\\n\\nvec4 filterVertexPosition(  vec2 aPosition )\\n{\\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\\n       \\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord(  vec2 aPosition )\\n{\\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\\n}\\n\\nvec2 getFilterCoord( vec2 aPosition )\\n{\\n    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\\n}   \\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition(aPosition);\\n    vTextureCoord = filterTextureCoord(aPosition);\\n    vMaskCoord = getFilterCoord(aPosition);\\n}\\n\";\n\nexport { vertex as default };\n//# sourceMappingURL=mask.vert.mjs.map\n","var source = \"struct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\nstruct MaskUniforms {\\n  uFilterMatrix:mat3x3<f32>,\\n  uMaskClamp:vec4<f32>,\\n  uAlpha:f32,\\n  uInverse:f32,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler : sampler;\\n\\n@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;\\n@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>,\\n    @location(1) filterUv : vec2<f32>,\\n};\\n\\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);\\n}\\n\\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\\n}\\n\\nfn getSize() -> vec2<f32>\\n{\\n  return gfu.uGlobalFrame.zw;\\n}\\n\\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition : vec2<f32>,\\n) -> VSOutput {\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   filterTextureCoord(aPosition),\\n   getFilterCoord(aPosition)\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @location(1) filterUv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n\\n    var maskClamp = filterUniforms.uMaskClamp;\\n    var uAlpha = filterUniforms.uAlpha;\\n\\n    var clip = step(3.5,\\n      step(maskClamp.x, filterUv.x) +\\n      step(maskClamp.y, filterUv.y) +\\n      step(filterUv.x, maskClamp.z) +\\n      step(filterUv.y, maskClamp.w));\\n\\n    var mask = textureSample(uMaskTexture, uSampler, filterUv);\\n    var source = textureSample(uTexture, uSampler, uv);\\n    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);\\n\\n    var a: f32 = alphaMul * mask.r * uAlpha * clip;\\n\\n    if (filterUniforms.uInverse == 1.0) {\\n        a = 1.0 - a;\\n    }\\n\\n    return source * a;\\n}\\n\";\n\nexport { source as default };\n//# sourceMappingURL=mask.wgsl.mjs.map\n","import { Matrix } from '../../maths/matrix/Matrix.mjs';\nimport { GlProgram } from '../../rendering/renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../../rendering/renderers/gpu/shader/GpuProgram.mjs';\nimport { UniformGroup } from '../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { TextureMatrix } from '../../rendering/renderers/shared/texture/TextureMatrix.mjs';\nimport { Filter } from '../Filter.mjs';\nimport fragment from './mask.frag.mjs';\nimport vertex from './mask.vert.mjs';\nimport source from './mask.wgsl.mjs';\n\n\"use strict\";\nclass MaskFilter extends Filter {\n  constructor(options) {\n    const { sprite, ...rest } = options;\n    const textureMatrix = new TextureMatrix(sprite.texture);\n    const filterUniforms = new UniformGroup({\n      uFilterMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uMaskClamp: { value: textureMatrix.uClampFrame, type: \"vec4<f32>\" },\n      uAlpha: { value: 1, type: \"f32\" },\n      uInverse: { value: options.inverse ? 1 : 0, type: \"f32\" }\n    });\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"mask-filter\"\n    });\n    super({\n      ...rest,\n      gpuProgram,\n      glProgram,\n      clipToViewport: false,\n      resources: {\n        filterUniforms,\n        uMaskTexture: sprite.texture.source\n      }\n    });\n    this.sprite = sprite;\n    this._textureMatrix = textureMatrix;\n  }\n  set inverse(value) {\n    this.resources.filterUniforms.uniforms.uInverse = value ? 1 : 0;\n  }\n  get inverse() {\n    return this.resources.filterUniforms.uniforms.uInverse === 1;\n  }\n  apply(filterManager, input, output, clearMode) {\n    this._textureMatrix.texture = this.sprite.texture;\n    filterManager.calculateSpriteMatrix(\n      this.resources.filterUniforms.uniforms.uFilterMatrix,\n      this.sprite\n    ).prepend(this._textureMatrix.mapCoord);\n    this.resources.uMaskTexture = this.sprite.texture.source;\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n}\n\nexport { MaskFilter };\n//# sourceMappingURL=MaskFilter.mjs.map\n","import { ExtensionType, extensions } from '../../../extensions/Extensions.mjs';\nimport { State } from '../../renderers/shared/state/State.mjs';\nimport { DefaultBatcher } from './DefaultBatcher.mjs';\n\n\"use strict\";\nconst _BatcherPipe = class _BatcherPipe {\n  constructor(renderer, adaptor) {\n    this.state = State.for2d();\n    this._batchersByInstructionSet = /* @__PURE__ */ Object.create(null);\n    /** A record of all active batchers, keyed by their names */\n    this._activeBatches = /* @__PURE__ */ Object.create(null);\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this._adaptor.init?.(this);\n  }\n  static getBatcher(name) {\n    return new this._availableBatchers[name]();\n  }\n  buildStart(instructionSet) {\n    let batchers = this._batchersByInstructionSet[instructionSet.uid];\n    if (!batchers) {\n      batchers = this._batchersByInstructionSet[instructionSet.uid] = /* @__PURE__ */ Object.create(null);\n      batchers.default || (batchers.default = new DefaultBatcher({\n        maxTextures: this.renderer.limits.maxBatchableTextures\n      }));\n    }\n    this._activeBatches = batchers;\n    this._activeBatch = this._activeBatches.default;\n    for (const i in this._activeBatches) {\n      this._activeBatches[i].begin();\n    }\n  }\n  addToBatch(batchableObject, instructionSet) {\n    if (this._activeBatch.name !== batchableObject.batcherName) {\n      this._activeBatch.break(instructionSet);\n      let batch = this._activeBatches[batchableObject.batcherName];\n      if (!batch) {\n        batch = this._activeBatches[batchableObject.batcherName] = _BatcherPipe.getBatcher(batchableObject.batcherName);\n        batch.begin();\n      }\n      this._activeBatch = batch;\n    }\n    this._activeBatch.add(batchableObject);\n  }\n  break(instructionSet) {\n    this._activeBatch.break(instructionSet);\n  }\n  buildEnd(instructionSet) {\n    this._activeBatch.break(instructionSet);\n    const batches = this._activeBatches;\n    for (const i in batches) {\n      const batch = batches[i];\n      const geometry = batch.geometry;\n      geometry.indexBuffer.setDataWithSize(batch.indexBuffer, batch.indexSize, true);\n      geometry.buffers[0].setDataWithSize(batch.attributeBuffer.float32View, batch.attributeSize, false);\n    }\n  }\n  upload(instructionSet) {\n    const batchers = this._batchersByInstructionSet[instructionSet.uid];\n    for (const i in batchers) {\n      const batcher = batchers[i];\n      const geometry = batcher.geometry;\n      if (batcher.dirty) {\n        batcher.dirty = false;\n        geometry.buffers[0].update(batcher.attributeSize * 4);\n      }\n    }\n  }\n  execute(batch) {\n    if (batch.action === \"startBatch\") {\n      const batcher = batch.batcher;\n      const geometry = batcher.geometry;\n      const shader = batcher.shader;\n      this._adaptor.start(this, geometry, shader);\n    }\n    this._adaptor.execute(this, batch);\n  }\n  destroy() {\n    this.state = null;\n    this.renderer = null;\n    this._adaptor = null;\n    for (const i in this._activeBatches) {\n      this._activeBatches[i].destroy();\n    }\n    this._activeBatches = null;\n  }\n};\n/** @ignore */\n_BatcherPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"batch\"\n};\n_BatcherPipe._availableBatchers = /* @__PURE__ */ Object.create(null);\nlet BatcherPipe = _BatcherPipe;\nextensions.handleByMap(ExtensionType.Batcher, BatcherPipe._availableBatchers);\nextensions.add(DefaultBatcher);\n\nexport { BatcherPipe };\n//# sourceMappingURL=BatcherPipe.mjs.map\n","\"use strict\";\nconst textureBit = {\n  name: \"texture-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n\n        struct TextureUniforms {\n            uTextureMatrix:mat3x3<f32>,\n        }\n\n        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            @group(2) @binding(0) var uTexture: texture_2d<f32>;\n            @group(2) @binding(1) var uSampler: sampler;\n\n\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            outColor = textureSample(uTexture, uSampler, vUV);\n        `\n    )\n  }\n};\nconst textureBitGl = {\n  name: \"texture-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            uniform mat3 uTextureMatrix;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* glsl */\n      `\n        uniform sampler2D uTexture;\n\n\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            outColor = texture(uTexture, vUV);\n        `\n    )\n  }\n};\n\nexport { textureBit, textureBitGl };\n//# sourceMappingURL=textureBit.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { FilterEffect } from '../../../filters/FilterEffect.mjs';\nimport { MaskFilter } from '../../../filters/mask/MaskFilter.mjs';\nimport { Bounds } from '../../../scene/container/bounds/Bounds.mjs';\nimport { getGlobalBounds } from '../../../scene/container/bounds/getGlobalBounds.mjs';\nimport { Sprite } from '../../../scene/sprite/Sprite.mjs';\nimport { BigPool } from '../../../utils/pool/PoolGroup.mjs';\nimport { Texture } from '../../renderers/shared/texture/Texture.mjs';\nimport { TexturePool } from '../../renderers/shared/texture/TexturePool.mjs';\nimport { RendererType } from '../../renderers/types.mjs';\n\n\"use strict\";\nconst tempBounds = new Bounds();\nclass AlphaMaskEffect extends FilterEffect {\n  constructor() {\n    super();\n    this.filters = [new MaskFilter({\n      sprite: new Sprite(Texture.EMPTY),\n      inverse: false,\n      resolution: \"inherit\",\n      antialias: \"inherit\"\n    })];\n  }\n  get sprite() {\n    return this.filters[0].sprite;\n  }\n  set sprite(value) {\n    this.filters[0].sprite = value;\n  }\n  get inverse() {\n    return this.filters[0].inverse;\n  }\n  set inverse(value) {\n    this.filters[0].inverse = value;\n  }\n}\nclass AlphaMaskPipe {\n  constructor(renderer) {\n    this._activeMaskStage = [];\n    this._renderer = renderer;\n  }\n  push(mask, maskedContainer, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"alphaMask\",\n      action: \"pushMaskBegin\",\n      mask,\n      inverse: maskedContainer._maskOptions.inverse,\n      canBundle: false,\n      maskedContainer\n    });\n    mask.inverse = maskedContainer._maskOptions.inverse;\n    if (mask.renderMaskToTexture) {\n      const maskContainer = mask.mask;\n      maskContainer.includeInBuild = true;\n      maskContainer.collectRenderables(\n        instructionSet,\n        renderer,\n        null\n      );\n      maskContainer.includeInBuild = false;\n    }\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"alphaMask\",\n      action: \"pushMaskEnd\",\n      mask,\n      maskedContainer,\n      inverse: maskedContainer._maskOptions.inverse,\n      canBundle: false\n    });\n  }\n  pop(mask, _maskedContainer, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"alphaMask\",\n      action: \"popMaskEnd\",\n      mask,\n      inverse: _maskedContainer._maskOptions.inverse,\n      canBundle: false\n    });\n  }\n  execute(instruction) {\n    const renderer = this._renderer;\n    const renderMask = instruction.mask.renderMaskToTexture;\n    if (instruction.action === \"pushMaskBegin\") {\n      const filterEffect = BigPool.get(AlphaMaskEffect);\n      filterEffect.inverse = instruction.inverse;\n      if (renderMask) {\n        instruction.mask.mask.measurable = true;\n        const bounds = getGlobalBounds(instruction.mask.mask, true, tempBounds);\n        instruction.mask.mask.measurable = false;\n        bounds.ceil();\n        const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n        const filterTexture = TexturePool.getOptimalTexture(\n          bounds.width,\n          bounds.height,\n          colorTextureSource._resolution,\n          colorTextureSource.antialias\n        );\n        renderer.renderTarget.push(filterTexture, true);\n        renderer.globalUniforms.push({\n          offset: bounds,\n          worldColor: 4294967295\n        });\n        const sprite = filterEffect.sprite;\n        sprite.texture = filterTexture;\n        sprite.worldTransform.tx = bounds.minX;\n        sprite.worldTransform.ty = bounds.minY;\n        this._activeMaskStage.push({\n          filterEffect,\n          maskedContainer: instruction.maskedContainer,\n          filterTexture\n        });\n      } else {\n        filterEffect.sprite = instruction.mask.mask;\n        this._activeMaskStage.push({\n          filterEffect,\n          maskedContainer: instruction.maskedContainer\n        });\n      }\n    } else if (instruction.action === \"pushMaskEnd\") {\n      const maskData = this._activeMaskStage[this._activeMaskStage.length - 1];\n      if (renderMask) {\n        if (renderer.type === RendererType.WEBGL) {\n          renderer.renderTarget.finishRenderPass();\n        }\n        renderer.renderTarget.pop();\n        renderer.globalUniforms.pop();\n      }\n      renderer.filter.push({\n        renderPipeId: \"filter\",\n        action: \"pushFilter\",\n        container: maskData.maskedContainer,\n        filterEffect: maskData.filterEffect,\n        canBundle: false\n      });\n    } else if (instruction.action === \"popMaskEnd\") {\n      renderer.filter.pop();\n      const maskData = this._activeMaskStage.pop();\n      if (renderMask) {\n        TexturePool.returnTexture(maskData.filterTexture);\n      }\n      BigPool.return(maskData.filterEffect);\n    }\n  }\n  destroy() {\n    this._renderer = null;\n    this._activeMaskStage = null;\n  }\n}\n/** @ignore */\nAlphaMaskPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"alphaMask\"\n};\n\nexport { AlphaMaskPipe };\n//# sourceMappingURL=AlphaMaskPipe.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass ColorMaskPipe {\n  constructor(renderer) {\n    this._colorStack = [];\n    this._colorStackIndex = 0;\n    this._currentColor = 0;\n    this._renderer = renderer;\n  }\n  buildStart() {\n    this._colorStack[0] = 15;\n    this._colorStackIndex = 1;\n    this._currentColor = 15;\n  }\n  push(mask, _container, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    const colorStack = this._colorStack;\n    colorStack[this._colorStackIndex] = colorStack[this._colorStackIndex - 1] & mask.mask;\n    const currentColor = this._colorStack[this._colorStackIndex];\n    if (currentColor !== this._currentColor) {\n      this._currentColor = currentColor;\n      instructionSet.add({\n        renderPipeId: \"colorMask\",\n        colorMask: currentColor,\n        canBundle: false\n      });\n    }\n    this._colorStackIndex++;\n  }\n  pop(_mask, _container, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    const colorStack = this._colorStack;\n    this._colorStackIndex--;\n    const currentColor = colorStack[this._colorStackIndex - 1];\n    if (currentColor !== this._currentColor) {\n      this._currentColor = currentColor;\n      instructionSet.add({\n        renderPipeId: \"colorMask\",\n        colorMask: currentColor,\n        canBundle: false\n      });\n    }\n  }\n  execute(instruction) {\n    const renderer = this._renderer;\n    renderer.colorMask.setMask(instruction.colorMask);\n  }\n  destroy() {\n    this._renderer = null;\n    this._colorStack = null;\n  }\n}\n/** @ignore */\nColorMaskPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"colorMask\"\n};\n\nexport { ColorMaskPipe };\n//# sourceMappingURL=ColorMaskPipe.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { CLEAR } from '../../renderers/gl/const.mjs';\nimport { STENCIL_MODES } from '../../renderers/shared/state/const.mjs';\n\n\"use strict\";\nclass StencilMaskPipe {\n  constructor(renderer) {\n    // used when building and also when executing..\n    this._maskStackHash = {};\n    this._maskHash = /* @__PURE__ */ new WeakMap();\n    this._renderer = renderer;\n  }\n  push(mask, _container, instructionSet) {\n    var _a;\n    const effect = mask;\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    renderer.renderPipes.blendMode.setBlendMode(effect.mask, \"none\", instructionSet);\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"pushMaskBegin\",\n      mask,\n      inverse: _container._maskOptions.inverse,\n      canBundle: false\n    });\n    const maskContainer = effect.mask;\n    maskContainer.includeInBuild = true;\n    if (!this._maskHash.has(effect)) {\n      this._maskHash.set(effect, {\n        instructionsStart: 0,\n        instructionsLength: 0\n      });\n    }\n    const maskData = this._maskHash.get(effect);\n    maskData.instructionsStart = instructionSet.instructionSize;\n    maskContainer.collectRenderables(\n      instructionSet,\n      renderer,\n      null\n    );\n    maskContainer.includeInBuild = false;\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"pushMaskEnd\",\n      mask,\n      inverse: _container._maskOptions.inverse,\n      canBundle: false\n    });\n    const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;\n    maskData.instructionsLength = instructionsLength;\n    const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n    (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);\n  }\n  pop(mask, _container, instructionSet) {\n    const effect = mask;\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    renderer.renderPipes.blendMode.setBlendMode(effect.mask, \"none\", instructionSet);\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"popMaskBegin\",\n      inverse: _container._maskOptions.inverse,\n      canBundle: false\n    });\n    const maskData = this._maskHash.get(mask);\n    for (let i = 0; i < maskData.instructionsLength; i++) {\n      instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];\n    }\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"popMaskEnd\",\n      canBundle: false\n    });\n  }\n  execute(instruction) {\n    var _a;\n    const renderer = this._renderer;\n    const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n    let maskStackIndex = (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);\n    if (instruction.action === \"pushMaskBegin\") {\n      renderer.renderTarget.ensureDepthStencil();\n      renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD, maskStackIndex);\n      maskStackIndex++;\n      renderer.colorMask.setMask(0);\n    } else if (instruction.action === \"pushMaskEnd\") {\n      if (instruction.inverse) {\n        renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);\n      } else {\n        renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n      }\n      renderer.colorMask.setMask(15);\n    } else if (instruction.action === \"popMaskBegin\") {\n      renderer.colorMask.setMask(0);\n      if (maskStackIndex !== 0) {\n        renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE, maskStackIndex);\n      } else {\n        renderer.renderTarget.clear(null, CLEAR.STENCIL);\n        renderer.stencil.setStencilMode(STENCIL_MODES.DISABLED, maskStackIndex);\n      }\n      maskStackIndex--;\n    } else if (instruction.action === \"popMaskEnd\") {\n      if (instruction.inverse) {\n        renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);\n      } else {\n        renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n      }\n      renderer.colorMask.setMask(15);\n    }\n    this._maskStackHash[renderTargetUid] = maskStackIndex;\n  }\n  destroy() {\n    this._renderer = null;\n    this._maskStackHash = null;\n    this._maskHash = null;\n  }\n}\nStencilMaskPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"stencilMask\"\n};\n\nexport { StencilMaskPipe };\n//# sourceMappingURL=StencilMaskPipe.mjs.map\n","import { warn } from '../../../../../utils/logging/warn.mjs';\nimport { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat.mjs';\n\n\"use strict\";\nfunction ensureAttributes(geometry, extractedData) {\n  for (const i in geometry.attributes) {\n    const attribute = geometry.attributes[i];\n    const attributeData = extractedData[i];\n    if (attributeData) {\n      attribute.format ?? (attribute.format = attributeData.format);\n      attribute.offset ?? (attribute.offset = attributeData.offset);\n      attribute.instance ?? (attribute.instance = attributeData.instance);\n    } else {\n      warn(`Attribute ${i} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);\n    }\n  }\n  ensureStartAndStride(geometry);\n}\nfunction ensureStartAndStride(geometry) {\n  const { buffers, attributes } = geometry;\n  const tempStride = {};\n  const tempStart = {};\n  for (const j in buffers) {\n    const buffer = buffers[j];\n    tempStride[buffer.uid] = 0;\n    tempStart[buffer.uid] = 0;\n  }\n  for (const j in attributes) {\n    const attribute = attributes[j];\n    tempStride[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n  }\n  for (const j in attributes) {\n    const attribute = attributes[j];\n    attribute.stride ?? (attribute.stride = tempStride[attribute.buffer.uid]);\n    attribute.start ?? (attribute.start = tempStart[attribute.buffer.uid]);\n    tempStart[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n  }\n}\n\nexport { ensureAttributes };\n//# sourceMappingURL=ensureAttributes.mjs.map\n","import { STENCIL_MODES } from '../../shared/state/const.mjs';\n\n\"use strict\";\nconst GpuStencilModesToPixi = [];\nGpuStencilModesToPixi[STENCIL_MODES.NONE] = void 0;\nGpuStencilModesToPixi[STENCIL_MODES.DISABLED] = {\n  stencilWriteMask: 0,\n  stencilReadMask: 0\n};\nGpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD] = {\n  stencilFront: {\n    compare: \"equal\",\n    passOp: \"increment-clamp\"\n  },\n  stencilBack: {\n    compare: \"equal\",\n    passOp: \"increment-clamp\"\n  }\n};\nGpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_REMOVE] = {\n  stencilFront: {\n    compare: \"equal\",\n    passOp: \"decrement-clamp\"\n  },\n  stencilBack: {\n    compare: \"equal\",\n    passOp: \"decrement-clamp\"\n  }\n};\nGpuStencilModesToPixi[STENCIL_MODES.MASK_ACTIVE] = {\n  stencilWriteMask: 0,\n  stencilFront: {\n    compare: \"equal\",\n    passOp: \"keep\"\n  },\n  stencilBack: {\n    compare: \"equal\",\n    passOp: \"keep\"\n  }\n};\nGpuStencilModesToPixi[STENCIL_MODES.INVERSE_MASK_ACTIVE] = {\n  stencilWriteMask: 0,\n  stencilFront: {\n    compare: \"not-equal\",\n    passOp: \"keep\"\n  },\n  stencilBack: {\n    compare: \"not-equal\",\n    passOp: \"keep\"\n  }\n};\n\nexport { GpuStencilModesToPixi };\n//# sourceMappingURL=GpuStencilModesToPixi.mjs.map\n","import { unsafeEvalSupported } from '../../../../utils/browser/unsafeEvalSupported.mjs';\nimport { Buffer } from '../buffer/Buffer.mjs';\nimport { BufferUsage } from '../buffer/const.mjs';\n\n\"use strict\";\nclass UboSystem {\n  constructor(adaptor) {\n    /** Cache of uniform buffer layouts and sync functions, so we don't have to re-create them */\n    this._syncFunctionHash = /* @__PURE__ */ Object.create(null);\n    this._adaptor = adaptor;\n    this._systemCheck();\n  }\n  /**\n   * Overridable function by `pixi.js/unsafe-eval` to silence\n   * throwing an error if platform doesn't support unsafe-evals.\n   * @private\n   */\n  _systemCheck() {\n    if (!unsafeEvalSupported()) {\n      throw new Error(\"Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.\");\n    }\n  }\n  ensureUniformGroup(uniformGroup) {\n    const uniformData = this.getUniformGroupData(uniformGroup);\n    uniformGroup.buffer || (uniformGroup.buffer = new Buffer({\n      data: new Float32Array(uniformData.layout.size / 4),\n      usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST\n    }));\n  }\n  getUniformGroupData(uniformGroup) {\n    return this._syncFunctionHash[uniformGroup._signature] || this._initUniformGroup(uniformGroup);\n  }\n  _initUniformGroup(uniformGroup) {\n    const uniformGroupSignature = uniformGroup._signature;\n    let uniformData = this._syncFunctionHash[uniformGroupSignature];\n    if (!uniformData) {\n      const elements = Object.keys(uniformGroup.uniformStructures).map((i) => uniformGroup.uniformStructures[i]);\n      const layout = this._adaptor.createUboElements(elements);\n      const syncFunction = this._generateUboSync(layout.uboElements);\n      uniformData = this._syncFunctionHash[uniformGroupSignature] = {\n        layout,\n        syncFunction\n      };\n    }\n    return this._syncFunctionHash[uniformGroupSignature];\n  }\n  _generateUboSync(uboElements) {\n    return this._adaptor.generateUboSync(uboElements);\n  }\n  syncUniformGroup(uniformGroup, data, offset) {\n    const uniformGroupData = this.getUniformGroupData(uniformGroup);\n    uniformGroup.buffer || (uniformGroup.buffer = new Buffer({\n      data: new Float32Array(uniformGroupData.layout.size / 4),\n      usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST\n    }));\n    let dataInt32 = null;\n    if (!data) {\n      data = uniformGroup.buffer.data;\n      dataInt32 = uniformGroup.buffer.dataInt32;\n    }\n    offset || (offset = 0);\n    uniformGroupData.syncFunction(uniformGroup.uniforms, data, dataInt32, offset);\n    return true;\n  }\n  updateUniformGroup(uniformGroup) {\n    if (uniformGroup.isStatic && !uniformGroup._dirtyId)\n      return false;\n    uniformGroup._dirtyId = 0;\n    const synced = this.syncUniformGroup(uniformGroup);\n    uniformGroup.buffer.update();\n    return synced;\n  }\n  destroy() {\n    this._syncFunctionHash = null;\n  }\n}\n\nexport { UboSystem };\n//# sourceMappingURL=UboSystem.mjs.map\n","\"use strict\";\nconst uniformParsers = [\n  // uploading pixi matrix object to mat3\n  {\n    type: \"mat3x3<f32>\",\n    test: (data) => {\n      const value = data.value;\n      return value.a !== void 0;\n    },\n    ubo: `\n            var matrix = uv[name].toArray(true);\n            data[offset] = matrix[0];\n            data[offset + 1] = matrix[1];\n            data[offset + 2] = matrix[2];\n            data[offset + 4] = matrix[3];\n            data[offset + 5] = matrix[4];\n            data[offset + 6] = matrix[5];\n            data[offset + 8] = matrix[6];\n            data[offset + 9] = matrix[7];\n            data[offset + 10] = matrix[8];\n        `,\n    uniform: `\n            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));\n        `\n  },\n  // uploading a pixi rectangle as a vec4\n  {\n    type: \"vec4<f32>\",\n    test: (data) => data.type === \"vec4<f32>\" && data.size === 1 && data.value.width !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n            data[offset + 2] = v.width;\n            data[offset + 3] = v.height;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                cv[2] = v.width;\n                cv[3] = v.height;\n                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);\n            }\n        `\n  },\n  // uploading a pixi point as a vec2\n  {\n    type: \"vec2<f32>\",\n    test: (data) => data.type === \"vec2<f32>\" && data.size === 1 && data.value.x !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                gl.uniform2f(ud[name].location, v.x, v.y);\n            }\n        `\n  },\n  // uploading a pixi color as a vec4\n  {\n    type: \"vec4<f32>\",\n    test: (data) => data.type === \"vec4<f32>\" && data.size === 1 && data.value.red !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n            data[offset + 3] = v.alpha;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                cv[3] = v.alpha;\n                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);\n            }\n        `\n  },\n  // uploading a pixi color as a vec3\n  {\n    type: \"vec3<f32>\",\n    test: (data) => data.type === \"vec3<f32>\" && data.size === 1 && data.value.red !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);\n            }\n        `\n  }\n];\n\nexport { uniformParsers };\n//# sourceMappingURL=uniformParsers.mjs.map\n","import { uniformParsers } from './uniformParsers.mjs';\n\n\"use strict\";\nfunction createUboSyncFunction(uboElements, parserCode, arrayGenerationFunction, singleSettersMap) {\n  const funcFragments = [`\n        var v = null;\n        var v2 = null;\n        var t = 0;\n        var index = 0;\n        var name = null;\n        var arrayOffset = null;\n    `];\n  let prev = 0;\n  for (let i = 0; i < uboElements.length; i++) {\n    const uboElement = uboElements[i];\n    const name = uboElement.data.name;\n    let parsed = false;\n    let offset = 0;\n    for (let j = 0; j < uniformParsers.length; j++) {\n      const uniformParser = uniformParsers[j];\n      if (uniformParser.test(uboElement.data)) {\n        offset = uboElement.offset / 4;\n        funcFragments.push(\n          `name = \"${name}\";`,\n          `offset += ${offset - prev};`,\n          uniformParsers[j][parserCode] || uniformParsers[j].ubo\n        );\n        parsed = true;\n        break;\n      }\n    }\n    if (!parsed) {\n      if (uboElement.data.size > 1) {\n        offset = uboElement.offset / 4;\n        funcFragments.push(arrayGenerationFunction(uboElement, offset - prev));\n      } else {\n        const template = singleSettersMap[uboElement.data.type];\n        offset = uboElement.offset / 4;\n        funcFragments.push(\n          /* wgsl */\n          `\n                    v = uv.${name};\n                    offset += ${offset - prev};\n                    ${template};\n                `\n        );\n      }\n    }\n    prev = offset;\n  }\n  const fragmentSrc = funcFragments.join(\"\\n\");\n  return new Function(\n    \"uv\",\n    \"data\",\n    \"dataInt32\",\n    \"offset\",\n    fragmentSrc\n  );\n}\n\nexport { createUboSyncFunction };\n//# sourceMappingURL=createUboSyncFunction.mjs.map\n","\"use strict\";\nfunction loopMatrix(col, row) {\n  const total = col * row;\n  return `\n        for (let i = 0; i < ${total}; i++) {\n            data[offset + (((i / ${col})|0) * 4) + (i % ${col})] = v[i];\n        }\n    `;\n}\nconst uboSyncFunctionsSTD40 = {\n  f32: `\n        data[offset] = v;`,\n  i32: `\n        dataInt32[offset] = v;`,\n  \"vec2<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];`,\n  \"vec3<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];`,\n  \"vec4<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];`,\n  \"vec2<i32>\": `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];`,\n  \"vec3<i32>\": `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];`,\n  \"vec4<i32>\": `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];\n        dataInt32[offset + 3] = v[3];`,\n  \"mat2x2<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 4] = v[2];\n        data[offset + 5] = v[3];`,\n  \"mat3x3<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];`,\n  \"mat4x4<f32>\": `\n        for (let i = 0; i < 16; i++) {\n            data[offset + i] = v[i];\n        }`,\n  \"mat3x2<f32>\": loopMatrix(3, 2),\n  \"mat4x2<f32>\": loopMatrix(4, 2),\n  \"mat2x3<f32>\": loopMatrix(2, 3),\n  \"mat4x3<f32>\": loopMatrix(4, 3),\n  \"mat2x4<f32>\": loopMatrix(2, 4),\n  \"mat3x4<f32>\": loopMatrix(3, 4)\n};\nconst uboSyncFunctionsWGSL = {\n  ...uboSyncFunctionsSTD40,\n  \"mat2x2<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];\n    `\n};\n\nexport { uboSyncFunctionsSTD40, uboSyncFunctionsWGSL };\n//# sourceMappingURL=uboSyncFunctions.mjs.map\n","\"use strict\";\nfunction calculateProjection(pm, x, y, width, height, flipY) {\n  const sign = flipY ? 1 : -1;\n  pm.identity();\n  pm.a = 1 / width * 2;\n  pm.d = sign * (1 / height * 2);\n  pm.tx = -1 - x * pm.a;\n  pm.ty = -sign - y * pm.d;\n  return pm;\n}\n\nexport { calculateProjection };\n//# sourceMappingURL=calculateProjection.mjs.map\n","import { GlobalResourceRegistry } from '../../../../../utils/pool/GlobalResourceRegistry.mjs';\nimport { CanvasSource } from '../sources/CanvasSource.mjs';\nimport { Texture } from '../Texture.mjs';\n\n\"use strict\";\nconst canvasCache = /* @__PURE__ */ new Map();\nGlobalResourceRegistry.register(canvasCache);\nfunction getCanvasTexture(canvas, options) {\n  if (!canvasCache.has(canvas)) {\n    const texture = new Texture({\n      source: new CanvasSource({\n        resource: canvas,\n        ...options\n      })\n    });\n    const onDestroy = () => {\n      if (canvasCache.get(canvas) === texture) {\n        canvasCache.delete(canvas);\n      }\n    };\n    texture.once(\"destroy\", onDestroy);\n    texture.source.once(\"destroy\", onDestroy);\n    canvasCache.set(canvas, texture);\n  }\n  return canvasCache.get(canvas);\n}\nfunction hasCachedCanvasTexture(canvas) {\n  return canvasCache.has(canvas);\n}\n\nexport { getCanvasTexture, hasCachedCanvasTexture };\n//# sourceMappingURL=getCanvasTexture.mjs.map\n","\"use strict\";\nfunction isRenderingToScreen(renderTarget) {\n  const resource = renderTarget.colorTexture.source.resource;\n  return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement && document.body.contains(resource);\n}\n\nexport { isRenderingToScreen };\n//# sourceMappingURL=isRenderingToScreen.mjs.map\n","import { uid } from '../../../../utils/data/uid.mjs';\nimport { TextureSource } from '../texture/sources/TextureSource.mjs';\nimport { Texture } from '../texture/Texture.mjs';\n\n\"use strict\";\nconst _RenderTarget = class _RenderTarget {\n  /**\n   * @param [descriptor] - Options for creating a render target.\n   */\n  constructor(descriptor = {}) {\n    /** unique id for this render target */\n    this.uid = uid(\"renderTarget\");\n    /**\n     * An array of textures that can be written to by the GPU - mostly this has one texture in Pixi, but you could\n     * write to multiple if required! (eg deferred lighting)\n     */\n    this.colorTextures = [];\n    this.dirtyId = 0;\n    this.isRoot = false;\n    this._size = new Float32Array(2);\n    /** if true, then when the render target is destroyed, it will destroy all the textures that were created for it. */\n    this._managedColorTextures = false;\n    descriptor = { ..._RenderTarget.defaultOptions, ...descriptor };\n    this.stencil = descriptor.stencil;\n    this.depth = descriptor.depth;\n    this.isRoot = descriptor.isRoot;\n    if (typeof descriptor.colorTextures === \"number\") {\n      this._managedColorTextures = true;\n      for (let i = 0; i < descriptor.colorTextures; i++) {\n        this.colorTextures.push(\n          new TextureSource({\n            width: descriptor.width,\n            height: descriptor.height,\n            resolution: descriptor.resolution,\n            antialias: descriptor.antialias\n          })\n        );\n      }\n    } else {\n      this.colorTextures = [...descriptor.colorTextures.map((texture) => texture.source)];\n      const colorSource = this.colorTexture.source;\n      this.resize(colorSource.width, colorSource.height, colorSource._resolution);\n    }\n    this.colorTexture.source.on(\"resize\", this.onSourceResize, this);\n    if (descriptor.depthStencilTexture || this.stencil) {\n      if (descriptor.depthStencilTexture instanceof Texture || descriptor.depthStencilTexture instanceof TextureSource) {\n        this.depthStencilTexture = descriptor.depthStencilTexture.source;\n      } else {\n        this.ensureDepthStencilTexture();\n      }\n    }\n  }\n  get size() {\n    const _size = this._size;\n    _size[0] = this.pixelWidth;\n    _size[1] = this.pixelHeight;\n    return _size;\n  }\n  get width() {\n    return this.colorTexture.source.width;\n  }\n  get height() {\n    return this.colorTexture.source.height;\n  }\n  get pixelWidth() {\n    return this.colorTexture.source.pixelWidth;\n  }\n  get pixelHeight() {\n    return this.colorTexture.source.pixelHeight;\n  }\n  get resolution() {\n    return this.colorTexture.source._resolution;\n  }\n  get colorTexture() {\n    return this.colorTextures[0];\n  }\n  onSourceResize(source) {\n    this.resize(source.width, source.height, source._resolution, true);\n  }\n  /**\n   * This will ensure a depthStencil texture is created for this render target.\n   * Most likely called by the mask system to make sure we have stencil buffer added.\n   * @internal\n   */\n  ensureDepthStencilTexture() {\n    if (!this.depthStencilTexture) {\n      this.depthStencilTexture = new TextureSource({\n        width: this.width,\n        height: this.height,\n        resolution: this.resolution,\n        format: \"depth24plus-stencil8\",\n        autoGenerateMipmaps: false,\n        antialias: false,\n        mipLevelCount: 1\n        // sampleCount: handled by the render target system..\n      });\n    }\n  }\n  resize(width, height, resolution = this.resolution, skipColorTexture = false) {\n    this.dirtyId++;\n    this.colorTextures.forEach((colorTexture, i) => {\n      if (skipColorTexture && i === 0)\n        return;\n      colorTexture.source.resize(width, height, resolution);\n    });\n    if (this.depthStencilTexture) {\n      this.depthStencilTexture.source.resize(width, height, resolution);\n    }\n  }\n  destroy() {\n    this.colorTexture.source.off(\"resize\", this.onSourceResize, this);\n    if (this._managedColorTextures) {\n      this.colorTextures.forEach((texture) => {\n        texture.destroy();\n      });\n    }\n    if (this.depthStencilTexture) {\n      this.depthStencilTexture.destroy();\n      delete this.depthStencilTexture;\n    }\n  }\n};\n/** The default options for a render target */\n_RenderTarget.defaultOptions = {\n  /** the width of the RenderTarget */\n  width: 0,\n  /** the height of the RenderTarget */\n  height: 0,\n  /** the resolution of the RenderTarget */\n  resolution: 1,\n  /** an array of textures, or a number indicating how many color textures there should be */\n  colorTextures: 1,\n  /** should this render target have a stencil buffer? */\n  stencil: false,\n  /** should this render target have a depth buffer? */\n  depth: false,\n  /** should this render target be antialiased? */\n  antialias: false,\n  // save on perf by default!\n  /** is this a root element, true if this is gl context owners render target */\n  isRoot: false\n};\nlet RenderTarget = _RenderTarget;\n\nexport { RenderTarget };\n//# sourceMappingURL=RenderTarget.mjs.map\n","import { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { CLEAR } from '../../gl/const.mjs';\nimport { calculateProjection } from '../../gpu/renderTarget/calculateProjection.mjs';\nimport { SystemRunner } from '../system/SystemRunner.mjs';\nimport { CanvasSource } from '../texture/sources/CanvasSource.mjs';\nimport { TextureSource } from '../texture/sources/TextureSource.mjs';\nimport { Texture } from '../texture/Texture.mjs';\nimport { getCanvasTexture } from '../texture/utils/getCanvasTexture.mjs';\nimport { isRenderingToScreen } from './isRenderingToScreen.mjs';\nimport { RenderTarget } from './RenderTarget.mjs';\n\n\"use strict\";\nclass RenderTargetSystem {\n  constructor(renderer) {\n    /** This is the root viewport for the render pass*/\n    this.rootViewPort = new Rectangle();\n    /** the current viewport that the gpu is using */\n    this.viewport = new Rectangle();\n    /**\n     * a runner that lets systems know if the active render target has changed.\n     * Eg the Stencil System needs to know so it can manage the stencil buffer\n     */\n    this.onRenderTargetChange = new SystemRunner(\"onRenderTargetChange\");\n    /** the projection matrix that is used by the shaders based on the active render target and the viewport */\n    this.projectionMatrix = new Matrix();\n    /** the default clear color for render targets */\n    this.defaultClearColor = [0, 0, 0, 0];\n    /**\n     * a hash that stores the render target for a given render surface. When you pass in a texture source,\n     * a render target is created for it. This map stores and makes it easy to retrieve the render target\n     */\n    this._renderSurfaceToRenderTargetHash = /* @__PURE__ */ new Map();\n    /** A hash that stores a gpu render target for a given render target. */\n    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);\n    /**\n     * A stack that stores the render target and frame that is currently being rendered to.\n     * When push is called, the current render target is stored in this stack.\n     * When pop is called, the previous render target is restored.\n     */\n    this._renderTargetStack = [];\n    this._renderer = renderer;\n    renderer.renderableGC.addManagedHash(this, \"_gpuRenderTargetHash\");\n  }\n  /** called when dev wants to finish a render pass */\n  finishRenderPass() {\n    this.adaptor.finishRenderPass(this.renderTarget);\n  }\n  /**\n   * called when the renderer starts to render a scene.\n   * @param options\n   * @param options.target - the render target to render to\n   * @param options.clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n   * @param options.clearColor - the color to clear to\n   * @param options.frame - the frame to render to\n   */\n  renderStart({\n    target,\n    clear,\n    clearColor,\n    frame\n  }) {\n    this._renderTargetStack.length = 0;\n    this.push(\n      target,\n      clear,\n      clearColor,\n      frame\n    );\n    this.rootViewPort.copyFrom(this.viewport);\n    this.rootRenderTarget = this.renderTarget;\n    this.renderingToScreen = isRenderingToScreen(this.rootRenderTarget);\n    this.adaptor.prerender?.(this.rootRenderTarget);\n  }\n  postrender() {\n    this.adaptor.postrender?.(this.rootRenderTarget);\n  }\n  /**\n   * Binding a render surface! This is the main function of the render target system.\n   * It will take the RenderSurface (which can be a texture, canvas, or render target) and bind it to the renderer.\n   * Once bound all draw calls will be rendered to the render surface.\n   *\n   * If a frame is not provide and the render surface is a texture, the frame of the texture will be used.\n   * @param renderSurface - the render surface to bind\n   * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n   * @param clearColor - the color to clear to\n   * @param frame - the frame to render to\n   * @returns the render target that was bound\n   */\n  bind(renderSurface, clear = true, clearColor, frame) {\n    const renderTarget = this.getRenderTarget(renderSurface);\n    const didChange = this.renderTarget !== renderTarget;\n    this.renderTarget = renderTarget;\n    this.renderSurface = renderSurface;\n    const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);\n    if (renderTarget.pixelWidth !== gpuRenderTarget.width || renderTarget.pixelHeight !== gpuRenderTarget.height) {\n      this.adaptor.resizeGpuRenderTarget(renderTarget);\n      gpuRenderTarget.width = renderTarget.pixelWidth;\n      gpuRenderTarget.height = renderTarget.pixelHeight;\n    }\n    const source = renderTarget.colorTexture;\n    const viewport = this.viewport;\n    const pixelWidth = source.pixelWidth;\n    const pixelHeight = source.pixelHeight;\n    if (!frame && renderSurface instanceof Texture) {\n      frame = renderSurface.frame;\n    }\n    if (frame) {\n      const resolution = source._resolution;\n      viewport.x = frame.x * resolution + 0.5 | 0;\n      viewport.y = frame.y * resolution + 0.5 | 0;\n      viewport.width = frame.width * resolution + 0.5 | 0;\n      viewport.height = frame.height * resolution + 0.5 | 0;\n    } else {\n      viewport.x = 0;\n      viewport.y = 0;\n      viewport.width = pixelWidth;\n      viewport.height = pixelHeight;\n    }\n    calculateProjection(\n      this.projectionMatrix,\n      0,\n      0,\n      viewport.width / source.resolution,\n      viewport.height / source.resolution,\n      !renderTarget.isRoot\n    );\n    this.adaptor.startRenderPass(renderTarget, clear, clearColor, viewport);\n    if (didChange) {\n      this.onRenderTargetChange.emit(renderTarget);\n    }\n    return renderTarget;\n  }\n  clear(target, clear = CLEAR.ALL, clearColor) {\n    if (!clear)\n      return;\n    if (target) {\n      target = this.getRenderTarget(target);\n    }\n    this.adaptor.clear(\n      target || this.renderTarget,\n      clear,\n      clearColor,\n      this.viewport\n    );\n  }\n  contextChange() {\n    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);\n  }\n  /**\n   * Push a render surface to the renderer. This will bind the render surface to the renderer,\n   * @param renderSurface - the render surface to push\n   * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n   * @param clearColor - the color to clear to\n   * @param frame - the frame to use when rendering to the render surface\n   */\n  push(renderSurface, clear = CLEAR.ALL, clearColor, frame) {\n    const renderTarget = this.bind(renderSurface, clear, clearColor, frame);\n    this._renderTargetStack.push({\n      renderTarget,\n      frame\n    });\n    return renderTarget;\n  }\n  /** Pops the current render target from the renderer and restores the previous render target. */\n  pop() {\n    this._renderTargetStack.pop();\n    const currentRenderTargetData = this._renderTargetStack[this._renderTargetStack.length - 1];\n    this.bind(currentRenderTargetData.renderTarget, false, null, currentRenderTargetData.frame);\n  }\n  /**\n   * Gets the render target from the provide render surface. Eg if its a texture,\n   * it will return the render target for the texture.\n   * If its a render target, it will return the same render target.\n   * @param renderSurface - the render surface to get the render target for\n   * @returns the render target for the render surface\n   */\n  getRenderTarget(renderSurface) {\n    if (renderSurface.isTexture) {\n      renderSurface = renderSurface.source;\n    }\n    return this._renderSurfaceToRenderTargetHash.get(renderSurface) ?? this._initRenderTarget(renderSurface);\n  }\n  /**\n   * Copies a render surface to another texture.\n   *\n   * NOTE:\n   * for sourceRenderSurfaceTexture, The render target must be something that is written too by the renderer\n   *\n   * The following is not valid:\n   * @example\n   * const canvas = document.createElement('canvas')\n   * canvas.width = 200;\n   * canvas.height = 200;\n   *\n   * const ctx = canvas2.getContext('2d')!\n   * ctx.fillStyle = 'red'\n   * ctx.fillRect(0, 0, 200, 200);\n   *\n   * const texture = RenderTexture.create({\n   *   width: 200,\n   *   height: 200,\n   * })\n   * const renderTarget = renderer.renderTarget.getRenderTarget(canvas2);\n   *\n   * renderer.renderTarget.copyToTexture(renderTarget,texture, {x:0,y:0},{width:200,height:200},{x:0,y:0});\n   *\n   * The best way to copy a canvas is to create a texture from it. Then render with that.\n   *\n   * Parsing in a RenderTarget canvas context (with a 2d context)\n   * @param sourceRenderSurfaceTexture - the render surface to copy from\n   * @param destinationTexture - the texture to copy to\n   * @param originSrc - the origin of the copy\n   * @param originSrc.x - the x origin of the copy\n   * @param originSrc.y - the y origin of the copy\n   * @param size - the size of the copy\n   * @param size.width - the width of the copy\n   * @param size.height - the height of the copy\n   * @param originDest - the destination origin (top left to paste from!)\n   * @param originDest.x - the x origin of the paste\n   * @param originDest.y - the y origin of the paste\n   */\n  copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {\n    if (originSrc.x < 0) {\n      size.width += originSrc.x;\n      originDest.x -= originSrc.x;\n      originSrc.x = 0;\n    }\n    if (originSrc.y < 0) {\n      size.height += originSrc.y;\n      originDest.y -= originSrc.y;\n      originSrc.y = 0;\n    }\n    const { pixelWidth, pixelHeight } = sourceRenderSurfaceTexture;\n    size.width = Math.min(size.width, pixelWidth - originSrc.x);\n    size.height = Math.min(size.height, pixelHeight - originSrc.y);\n    return this.adaptor.copyToTexture(\n      sourceRenderSurfaceTexture,\n      destinationTexture,\n      originSrc,\n      size,\n      originDest\n    );\n  }\n  /**\n   * ensures that we have a depth stencil buffer available to render to\n   * This is used by the mask system to make sure we have a stencil buffer.\n   */\n  ensureDepthStencil() {\n    if (!this.renderTarget.stencil) {\n      this.renderTarget.stencil = true;\n      this.adaptor.startRenderPass(this.renderTarget, false, null, this.viewport);\n    }\n  }\n  /** nukes the render target system */\n  destroy() {\n    this._renderer = null;\n    this._renderSurfaceToRenderTargetHash.forEach((renderTarget, key) => {\n      if (renderTarget !== key) {\n        renderTarget.destroy();\n      }\n    });\n    this._renderSurfaceToRenderTargetHash.clear();\n    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);\n  }\n  _initRenderTarget(renderSurface) {\n    let renderTarget = null;\n    if (CanvasSource.test(renderSurface)) {\n      renderSurface = getCanvasTexture(renderSurface).source;\n    }\n    if (renderSurface instanceof RenderTarget) {\n      renderTarget = renderSurface;\n    } else if (renderSurface instanceof TextureSource) {\n      renderTarget = new RenderTarget({\n        colorTextures: [renderSurface]\n      });\n      if (renderSurface.source instanceof CanvasSource) {\n        renderTarget.isRoot = true;\n      }\n      renderSurface.once(\"destroy\", () => {\n        renderTarget.destroy();\n        this._renderSurfaceToRenderTargetHash.delete(renderSurface);\n        const gpuRenderTarget = this._gpuRenderTargetHash[renderTarget.uid];\n        if (gpuRenderTarget) {\n          this._gpuRenderTargetHash[renderTarget.uid] = null;\n          this.adaptor.destroyGpuRenderTarget(gpuRenderTarget);\n        }\n      });\n    }\n    this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);\n    return renderTarget;\n  }\n  getGpuRenderTarget(renderTarget) {\n    return this._gpuRenderTargetHash[renderTarget.uid] || (this._gpuRenderTargetHash[renderTarget.uid] = this.adaptor.initGpuRenderTarget(renderTarget));\n  }\n  resetState() {\n    this.renderTarget = null;\n    this.renderSurface = null;\n  }\n}\n\nexport { RenderTargetSystem };\n//# sourceMappingURL=RenderTargetSystem.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid.mjs';\n\n\"use strict\";\nclass BufferResource extends EventEmitter {\n  /**\n   * Create a new Buffer Resource.\n   * @param options - The options for the buffer resource\n   * @param options.buffer - The underlying buffer that this resource is using\n   * @param options.offset - The offset of the buffer this resource is using.\n   * If not provided, then it will use the offset of the buffer.\n   * @param options.size - The size of the buffer this resource is using.\n   * If not provided, then it will use the size of the buffer.\n   */\n  constructor({ buffer, offset, size }) {\n    super();\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n    /** a unique id for this uniform group used through the renderer */\n    this.uid = uid(\"buffer\");\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     */\n    this._resourceType = \"bufferResource\";\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     */\n    this._touched = 0;\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     */\n    this._resourceId = uid(\"resource\");\n    /**\n     * A cheeky hint to the GL renderer to let it know this is a BufferResource\n     * @internal\n     */\n    this._bufferResource = true;\n    /**\n     * Has the Buffer resource been destroyed?\n     * @readonly\n     */\n    this.destroyed = false;\n    this.buffer = buffer;\n    this.offset = offset | 0;\n    this.size = size;\n    this.buffer.on(\"change\", this.onBufferChange, this);\n  }\n  onBufferChange() {\n    this._resourceId = uid(\"resource\");\n    this.emit(\"change\", this);\n  }\n  /**\n   * Destroys this resource. Make sure the underlying buffer is not used anywhere else\n   * if you want to destroy it as well, or code will explode\n   * @param destroyBuffer - Should the underlying buffer be destroyed as well?\n   */\n  destroy(destroyBuffer = false) {\n    this.destroyed = true;\n    if (destroyBuffer) {\n      this.buffer.destroy();\n    }\n    this.emit(\"change\", this);\n    this.buffer = null;\n    this.removeAllListeners();\n  }\n}\n\nexport { BufferResource };\n//# sourceMappingURL=BufferResource.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass CustomRenderPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  updateRenderable() {\n  }\n  destroyRenderable() {\n  }\n  validateRenderable() {\n    return false;\n  }\n  addRenderable(container, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add(container);\n  }\n  execute(container) {\n    if (!container.isRenderable)\n      return;\n    container.render(this._renderer);\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\nCustomRenderPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"customRender\"\n};\n\nexport { CustomRenderPipe };\n//# sourceMappingURL=CustomRenderPipe.mjs.map\n","\"use strict\";\nfunction executeInstructions(renderGroup, renderer) {\n  const instructionSet = renderGroup.instructionSet;\n  const instructions = instructionSet.instructions;\n  for (let i = 0; i < instructionSet.instructionSize; i++) {\n    const instruction = instructions[i];\n    renderer[instruction.renderPipeId].execute(instruction);\n  }\n}\n\nexport { executeInstructions };\n//# sourceMappingURL=executeInstructions.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { Matrix } from '../../maths/matrix/Matrix.mjs';\nimport { BigPool } from '../../utils/pool/PoolGroup.mjs';\nimport { BatchableSprite } from '../sprite/BatchableSprite.mjs';\nimport { executeInstructions } from './utils/executeInstructions.mjs';\n\n\"use strict\";\nconst tempMatrix = new Matrix();\nclass RenderGroupPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  addRenderGroup(renderGroup, instructionSet) {\n    if (renderGroup.isCachedAsTexture) {\n      this._addRenderableCacheAsTexture(renderGroup, instructionSet);\n    } else {\n      this._addRenderableDirect(renderGroup, instructionSet);\n    }\n  }\n  execute(renderGroup) {\n    if (!renderGroup.isRenderable)\n      return;\n    if (renderGroup.isCachedAsTexture) {\n      this._executeCacheAsTexture(renderGroup);\n    } else {\n      this._executeDirect(renderGroup);\n    }\n  }\n  destroy() {\n    this._renderer = null;\n  }\n  _addRenderableDirect(renderGroup, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    if (renderGroup._batchableRenderGroup) {\n      BigPool.return(renderGroup._batchableRenderGroup);\n      renderGroup._batchableRenderGroup = null;\n    }\n    instructionSet.add(renderGroup);\n  }\n  _addRenderableCacheAsTexture(renderGroup, instructionSet) {\n    const batchableRenderGroup = renderGroup._batchableRenderGroup ?? (renderGroup._batchableRenderGroup = BigPool.get(BatchableSprite));\n    batchableRenderGroup.renderable = renderGroup.root;\n    batchableRenderGroup.transform = renderGroup.root.relativeGroupTransform;\n    batchableRenderGroup.texture = renderGroup.texture;\n    batchableRenderGroup.bounds = renderGroup._textureBounds;\n    instructionSet.add(renderGroup);\n    this._renderer.renderPipes.blendMode.pushBlendMode(renderGroup, renderGroup.root.groupBlendMode, instructionSet);\n    this._renderer.renderPipes.batch.addToBatch(batchableRenderGroup, instructionSet);\n    this._renderer.renderPipes.blendMode.popBlendMode(instructionSet);\n  }\n  _executeCacheAsTexture(renderGroup) {\n    if (renderGroup.textureNeedsUpdate) {\n      renderGroup.textureNeedsUpdate = false;\n      const worldTransformMatrix = tempMatrix.identity().translate(\n        -renderGroup._textureBounds.x,\n        -renderGroup._textureBounds.y\n      );\n      this._renderer.renderTarget.push(renderGroup.texture, true, null, renderGroup.texture.frame);\n      this._renderer.globalUniforms.push({\n        worldTransformMatrix,\n        worldColor: 4294967295,\n        offset: { x: 0, y: 0 }\n      });\n      executeInstructions(renderGroup, this._renderer.renderPipes);\n      this._renderer.renderTarget.finishRenderPass();\n      this._renderer.renderTarget.pop();\n      this._renderer.globalUniforms.pop();\n    }\n    renderGroup._batchableRenderGroup._batcher.updateElement(renderGroup._batchableRenderGroup);\n    renderGroup._batchableRenderGroup._batcher.geometry.buffers[0].update();\n  }\n  _executeDirect(renderGroup) {\n    this._renderer.globalUniforms.push({\n      worldTransformMatrix: renderGroup.inverseParentTextureTransform,\n      worldColor: renderGroup.worldColorAlpha\n    });\n    executeInstructions(renderGroup, this._renderer.renderPipes);\n    this._renderer.globalUniforms.pop();\n  }\n}\nRenderGroupPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"renderGroup\"\n};\n\nexport { RenderGroupPipe };\n//# sourceMappingURL=RenderGroupPipe.mjs.map\n","\"use strict\";\nfunction clearList(list, index) {\n  index || (index = 0);\n  for (let j = index; j < list.length; j++) {\n    if (list[j]) {\n      list[j] = null;\n    } else {\n      break;\n    }\n  }\n}\n\nexport { clearList };\n//# sourceMappingURL=clearList.mjs.map\n","import { Container, UPDATE_VISIBLE, UPDATE_COLOR, UPDATE_BLEND } from '../Container.mjs';\nimport { clearList } from './clearList.mjs';\nimport { multiplyColors } from './multiplyColors.mjs';\n\n\"use strict\";\nconst tempContainer = new Container();\nconst UPDATE_BLEND_COLOR_VISIBLE = UPDATE_VISIBLE | UPDATE_COLOR | UPDATE_BLEND;\nfunction updateRenderGroupTransforms(renderGroup, updateChildRenderGroups = false) {\n  updateRenderGroupTransform(renderGroup);\n  const childrenToUpdate = renderGroup.childrenToUpdate;\n  const updateTick = renderGroup.updateTick++;\n  for (const j in childrenToUpdate) {\n    const renderGroupDepth = Number(j);\n    const childrenAtDepth = childrenToUpdate[j];\n    const list = childrenAtDepth.list;\n    const index = childrenAtDepth.index;\n    for (let i = 0; i < index; i++) {\n      const child = list[i];\n      if (child.parentRenderGroup === renderGroup && child.relativeRenderGroupDepth === renderGroupDepth) {\n        updateTransformAndChildren(child, updateTick, 0);\n      }\n    }\n    clearList(list, index);\n    childrenAtDepth.index = 0;\n  }\n  if (updateChildRenderGroups) {\n    for (let i = 0; i < renderGroup.renderGroupChildren.length; i++) {\n      updateRenderGroupTransforms(renderGroup.renderGroupChildren[i], updateChildRenderGroups);\n    }\n  }\n}\nfunction updateRenderGroupTransform(renderGroup) {\n  const root = renderGroup.root;\n  let worldAlpha;\n  if (renderGroup.renderGroupParent) {\n    const renderGroupParent = renderGroup.renderGroupParent;\n    renderGroup.worldTransform.appendFrom(\n      root.relativeGroupTransform,\n      renderGroupParent.worldTransform\n    );\n    renderGroup.worldColor = multiplyColors(\n      root.groupColor,\n      renderGroupParent.worldColor\n    );\n    worldAlpha = root.groupAlpha * renderGroupParent.worldAlpha;\n  } else {\n    renderGroup.worldTransform.copyFrom(root.localTransform);\n    renderGroup.worldColor = root.localColor;\n    worldAlpha = root.localAlpha;\n  }\n  worldAlpha = worldAlpha < 0 ? 0 : worldAlpha > 1 ? 1 : worldAlpha;\n  renderGroup.worldAlpha = worldAlpha;\n  renderGroup.worldColorAlpha = renderGroup.worldColor + ((worldAlpha * 255 | 0) << 24);\n}\nfunction updateTransformAndChildren(container, updateTick, updateFlags) {\n  if (updateTick === container.updateTick)\n    return;\n  container.updateTick = updateTick;\n  container.didChange = false;\n  const localTransform = container.localTransform;\n  container.updateLocalTransform();\n  const parent = container.parent;\n  if (parent && !parent.renderGroup) {\n    updateFlags |= container._updateFlags;\n    container.relativeGroupTransform.appendFrom(\n      localTransform,\n      parent.relativeGroupTransform\n    );\n    if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {\n      updateColorBlendVisibility(container, parent, updateFlags);\n    }\n  } else {\n    updateFlags = container._updateFlags;\n    container.relativeGroupTransform.copyFrom(localTransform);\n    if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {\n      updateColorBlendVisibility(container, tempContainer, updateFlags);\n    }\n  }\n  if (!container.renderGroup) {\n    const children = container.children;\n    const length = children.length;\n    for (let i = 0; i < length; i++) {\n      updateTransformAndChildren(children[i], updateTick, updateFlags);\n    }\n    const renderGroup = container.parentRenderGroup;\n    const renderable = container;\n    if (renderable.renderPipeId && !renderGroup.structureDidChange) {\n      renderGroup.updateRenderable(renderable);\n    }\n  }\n}\nfunction updateColorBlendVisibility(container, parent, updateFlags) {\n  if (updateFlags & UPDATE_COLOR) {\n    container.groupColor = multiplyColors(\n      container.localColor,\n      parent.groupColor\n    );\n    let groupAlpha = container.localAlpha * parent.groupAlpha;\n    groupAlpha = groupAlpha < 0 ? 0 : groupAlpha > 1 ? 1 : groupAlpha;\n    container.groupAlpha = groupAlpha;\n    container.groupColorAlpha = container.groupColor + ((groupAlpha * 255 | 0) << 24);\n  }\n  if (updateFlags & UPDATE_BLEND) {\n    container.groupBlendMode = container.localBlendMode === \"inherit\" ? parent.groupBlendMode : container.localBlendMode;\n  }\n  if (updateFlags & UPDATE_VISIBLE) {\n    container.globalDisplayStatus = container.localDisplayStatus & parent.globalDisplayStatus;\n  }\n  container._updateFlags = 0;\n}\n\nexport { updateRenderGroupTransform, updateRenderGroupTransforms, updateTransformAndChildren };\n//# sourceMappingURL=updateRenderGroupTransforms.mjs.map\n","\"use strict\";\nfunction validateRenderables(renderGroup, renderPipes) {\n  const { list } = renderGroup.childrenRenderablesToUpdate;\n  let rebuildRequired = false;\n  for (let i = 0; i < renderGroup.childrenRenderablesToUpdate.index; i++) {\n    const container = list[i];\n    const renderable = container;\n    const pipe = renderPipes[renderable.renderPipeId];\n    rebuildRequired = pipe.validateRenderable(container);\n    if (rebuildRequired) {\n      break;\n    }\n  }\n  renderGroup.structureDidChange = rebuildRequired;\n  return rebuildRequired;\n}\n\nexport { validateRenderables };\n//# sourceMappingURL=validateRenderables.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { Matrix } from '../../maths/matrix/Matrix.mjs';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool.mjs';\nimport { TextureStyle } from '../../rendering/renderers/shared/texture/TextureStyle.mjs';\nimport { Bounds } from './bounds/Bounds.mjs';\nimport { clearList } from './utils/clearList.mjs';\nimport { executeInstructions } from './utils/executeInstructions.mjs';\nimport { updateRenderGroupTransforms } from './utils/updateRenderGroupTransforms.mjs';\nimport { validateRenderables } from './utils/validateRenderables.mjs';\n\n\"use strict\";\nconst tempMatrix = new Matrix();\nclass RenderGroupSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  render({ container, transform }) {\n    const parent = container.parent;\n    const renderGroupParent = container.renderGroup.renderGroupParent;\n    container.parent = null;\n    container.renderGroup.renderGroupParent = null;\n    const renderer = this._renderer;\n    const originalLocalTransform = tempMatrix;\n    if (transform) {\n      originalLocalTransform.copyFrom(container.renderGroup.localTransform);\n      container.renderGroup.localTransform.copyFrom(transform);\n    }\n    const renderPipes = renderer.renderPipes;\n    this._updateCachedRenderGroups(container.renderGroup, null);\n    this._updateRenderGroups(container.renderGroup);\n    renderer.globalUniforms.start({\n      worldTransformMatrix: transform ? container.renderGroup.localTransform : container.renderGroup.worldTransform,\n      worldColor: container.renderGroup.worldColorAlpha\n    });\n    executeInstructions(container.renderGroup, renderPipes);\n    if (renderPipes.uniformBatch) {\n      renderPipes.uniformBatch.renderEnd();\n    }\n    if (transform) {\n      container.renderGroup.localTransform.copyFrom(originalLocalTransform);\n    }\n    container.parent = parent;\n    container.renderGroup.renderGroupParent = renderGroupParent;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n  _updateCachedRenderGroups(renderGroup, closestCacheAsTexture) {\n    renderGroup._parentCacheAsTextureRenderGroup = closestCacheAsTexture;\n    if (renderGroup.isCachedAsTexture) {\n      if (!renderGroup.textureNeedsUpdate)\n        return;\n      closestCacheAsTexture = renderGroup;\n    }\n    for (let i = renderGroup.renderGroupChildren.length - 1; i >= 0; i--) {\n      this._updateCachedRenderGroups(renderGroup.renderGroupChildren[i], closestCacheAsTexture);\n    }\n    renderGroup.invalidateMatrices();\n    if (renderGroup.isCachedAsTexture) {\n      if (renderGroup.textureNeedsUpdate) {\n        const bounds = renderGroup.root.getLocalBounds();\n        bounds.ceil();\n        const lastTexture = renderGroup.texture;\n        if (renderGroup.texture) {\n          TexturePool.returnTexture(renderGroup.texture, true);\n        }\n        const renderer = this._renderer;\n        const resolution = renderGroup.textureOptions.resolution || renderer.view.resolution;\n        const antialias = renderGroup.textureOptions.antialias ?? renderer.view.antialias;\n        const scaleMode = renderGroup.textureOptions.scaleMode ?? \"linear\";\n        const texture = TexturePool.getOptimalTexture(\n          bounds.width,\n          bounds.height,\n          resolution,\n          antialias\n        );\n        texture._source.style = new TextureStyle({ scaleMode });\n        renderGroup.texture = texture;\n        renderGroup._textureBounds || (renderGroup._textureBounds = new Bounds());\n        renderGroup._textureBounds.copyFrom(bounds);\n        if (lastTexture !== renderGroup.texture) {\n          if (renderGroup.renderGroupParent) {\n            renderGroup.renderGroupParent.structureDidChange = true;\n          }\n        }\n      }\n    } else if (renderGroup.texture) {\n      TexturePool.returnTexture(renderGroup.texture, true);\n      renderGroup.texture = null;\n    }\n  }\n  _updateRenderGroups(renderGroup) {\n    const renderer = this._renderer;\n    const renderPipes = renderer.renderPipes;\n    renderGroup.runOnRender(renderer);\n    renderGroup.instructionSet.renderPipes = renderPipes;\n    if (!renderGroup.structureDidChange) {\n      validateRenderables(renderGroup, renderPipes);\n    } else {\n      clearList(renderGroup.childrenRenderablesToUpdate.list, 0);\n    }\n    updateRenderGroupTransforms(renderGroup);\n    if (renderGroup.structureDidChange) {\n      renderGroup.structureDidChange = false;\n      this._buildInstructions(renderGroup, renderer);\n    } else {\n      this._updateRenderables(renderGroup);\n    }\n    renderGroup.childrenRenderablesToUpdate.index = 0;\n    renderer.renderPipes.batch.upload(renderGroup.instructionSet);\n    if (renderGroup.isCachedAsTexture && !renderGroup.textureNeedsUpdate)\n      return;\n    for (let i = 0; i < renderGroup.renderGroupChildren.length; i++) {\n      this._updateRenderGroups(renderGroup.renderGroupChildren[i]);\n    }\n  }\n  _updateRenderables(renderGroup) {\n    const { list, index } = renderGroup.childrenRenderablesToUpdate;\n    for (let i = 0; i < index; i++) {\n      const container = list[i];\n      if (container.didViewUpdate) {\n        renderGroup.updateRenderable(container);\n      }\n    }\n    clearList(list, index);\n  }\n  _buildInstructions(renderGroup, rendererOrPipes) {\n    const root = renderGroup.root;\n    const instructionSet = renderGroup.instructionSet;\n    instructionSet.reset();\n    const renderer = rendererOrPipes.renderPipes ? rendererOrPipes : rendererOrPipes.batch.renderer;\n    const renderPipes = renderer.renderPipes;\n    renderPipes.batch.buildStart(instructionSet);\n    renderPipes.blendMode.buildStart();\n    renderPipes.colorMask.buildStart();\n    if (root.sortableChildren) {\n      root.sortChildren();\n    }\n    root.collectRenderablesWithEffects(instructionSet, renderer, null);\n    renderPipes.batch.buildEnd(instructionSet);\n    renderPipes.blendMode.buildEnd(instructionSet);\n  }\n}\n/** @ignore */\nRenderGroupSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"renderGroup\"\n};\n\nexport { RenderGroupSystem };\n//# sourceMappingURL=RenderGroupSystem.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { BatchableSprite } from './BatchableSprite.mjs';\n\n\"use strict\";\nclass SpritePipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  addRenderable(sprite, instructionSet) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (sprite.didViewUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);\n  }\n  updateRenderable(sprite) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (sprite.didViewUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    gpuSprite._batcher.updateElement(gpuSprite);\n  }\n  validateRenderable(sprite) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    return !gpuSprite._batcher.checkAndUpdateTexture(\n      gpuSprite,\n      sprite._texture\n    );\n  }\n  _updateBatchableSprite(sprite, batchableSprite) {\n    batchableSprite.bounds = sprite.visualBounds;\n    batchableSprite.texture = sprite._texture;\n  }\n  _getGpuSprite(sprite) {\n    return sprite._gpuData[this._renderer.uid] || this._initGPUSprite(sprite);\n  }\n  _initGPUSprite(sprite) {\n    const batchableSprite = new BatchableSprite();\n    batchableSprite.renderable = sprite;\n    batchableSprite.transform = sprite.groupTransform;\n    batchableSprite.texture = sprite._texture;\n    batchableSprite.bounds = sprite.visualBounds;\n    batchableSprite.roundPixels = this._renderer._roundPixels | sprite._roundPixels;\n    sprite._gpuData[this._renderer.uid] = batchableSprite;\n    return batchableSprite;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nSpritePipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"sprite\"\n};\n\nexport { SpritePipe };\n//# sourceMappingURL=SpritePipe.mjs.map\n","import { Color } from '../../../../color/Color.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { warn } from '../../../../utils/logging/warn.mjs';\n\n\"use strict\";\nconst _BackgroundSystem = class _BackgroundSystem {\n  constructor() {\n    this.clearBeforeRender = true;\n    this._backgroundColor = new Color(0);\n    this.color = this._backgroundColor;\n    this.alpha = 1;\n  }\n  /**\n   * initiates the background system\n   * @param options - the options for the background colors\n   */\n  init(options) {\n    options = { ..._BackgroundSystem.defaultOptions, ...options };\n    this.clearBeforeRender = options.clearBeforeRender;\n    this.color = options.background || options.backgroundColor || this._backgroundColor;\n    this.alpha = options.backgroundAlpha;\n    this._backgroundColor.setAlpha(options.backgroundAlpha);\n  }\n  /** The background color to fill if not transparent */\n  get color() {\n    return this._backgroundColor;\n  }\n  set color(value) {\n    const incoming = Color.shared.setValue(value);\n    if (incoming.alpha < 1 && this._backgroundColor.alpha === 1) {\n      warn(\n        \"Cannot set a transparent background on an opaque canvas. To enable transparency, set backgroundAlpha < 1 when initializing your Application.\"\n      );\n    }\n    this._backgroundColor.setValue(value);\n  }\n  /** The background color alpha. Setting this to 0 will make the canvas transparent. */\n  get alpha() {\n    return this._backgroundColor.alpha;\n  }\n  set alpha(value) {\n    this._backgroundColor.setAlpha(value);\n  }\n  /** The background color as an [R, G, B, A] array. */\n  get colorRgba() {\n    return this._backgroundColor.toArray();\n  }\n  /**\n   * destroys the background system\n   * @internal\n   */\n  destroy() {\n  }\n};\n/** @ignore */\n_BackgroundSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"background\",\n  priority: 0\n};\n/** default options used by the system */\n_BackgroundSystem.defaultOptions = {\n  /**\n   * {@link WebGLOptions.backgroundAlpha}\n   * @default 1\n   */\n  backgroundAlpha: 1,\n  /**\n   * {@link WebGLOptions.backgroundColor}\n   * @default 0x000000\n   */\n  backgroundColor: 0,\n  /**\n   * {@link WebGLOptions.clearBeforeRender}\n   * @default true\n   */\n  clearBeforeRender: true\n};\nlet BackgroundSystem = _BackgroundSystem;\n\nexport { BackgroundSystem };\n//# sourceMappingURL=BackgroundSystem.mjs.map\n","import { extensions, ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { FilterEffect } from '../../../../filters/FilterEffect.mjs';\nimport { RenderGroup } from '../../../../scene/container/RenderGroup.mjs';\nimport { warn } from '../../../../utils/logging/warn.mjs';\n\n\"use strict\";\nconst BLEND_MODE_FILTERS = {};\nextensions.handle(ExtensionType.BlendMode, (value) => {\n  if (!value.name) {\n    throw new Error(\"BlendMode extension must have a name property\");\n  }\n  BLEND_MODE_FILTERS[value.name] = value.ref;\n}, (value) => {\n  delete BLEND_MODE_FILTERS[value.name];\n});\nclass BlendModePipe {\n  constructor(renderer) {\n    this._blendModeStack = [];\n    this._isAdvanced = false;\n    this._filterHash = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n    this._renderer.runners.prerender.add(this);\n  }\n  prerender() {\n    this._activeBlendMode = \"normal\";\n    this._isAdvanced = false;\n  }\n  /**\n   * Push a blend mode onto the internal stack and apply it to the instruction set if needed.\n   * @param renderable - The renderable or {@link RenderGroup} associated with the change.\n   * @param blendMode - The blend mode to activate.\n   * @param instructionSet - The instruction set being built.\n   */\n  pushBlendMode(renderable, blendMode, instructionSet) {\n    this._blendModeStack.push(blendMode);\n    this.setBlendMode(renderable, blendMode, instructionSet);\n  }\n  /**\n   * Pop the last blend mode from the stack and apply the new top-of-stack mode.\n   * @param instructionSet - The instruction set being built.\n   */\n  popBlendMode(instructionSet) {\n    this._blendModeStack.pop();\n    const blendMode = this._blendModeStack[this._activeBlendMode.length - 1] ?? \"normal\";\n    this.setBlendMode(null, blendMode, instructionSet);\n  }\n  /**\n   * Ensure a blend mode switch is added to the instruction set when the mode changes.\n   * If an advanced blend mode is active, subsequent renderables will be collected so they can be\n   * rendered within a single filter pass.\n   * @param renderable - The renderable or {@link RenderGroup} to associate with the change, or null when unwinding.\n   * @param blendMode - The target blend mode.\n   * @param instructionSet - The instruction set being built.\n   */\n  setBlendMode(renderable, blendMode, instructionSet) {\n    const isRenderGroup = renderable instanceof RenderGroup;\n    if (this._activeBlendMode === blendMode) {\n      if (this._isAdvanced && renderable && !isRenderGroup) {\n        this._renderableList?.push(renderable);\n      }\n      return;\n    }\n    if (this._isAdvanced)\n      this._endAdvancedBlendMode(instructionSet);\n    this._activeBlendMode = blendMode;\n    if (!renderable)\n      return;\n    this._isAdvanced = !!BLEND_MODE_FILTERS[blendMode];\n    if (this._isAdvanced)\n      this._beginAdvancedBlendMode(renderable, instructionSet);\n  }\n  _beginAdvancedBlendMode(renderable, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    const blendMode = this._activeBlendMode;\n    if (!BLEND_MODE_FILTERS[blendMode]) {\n      warn(`Unable to assign BlendMode: '${blendMode}'. You may want to include: import 'pixi.js/advanced-blend-modes'`);\n      return;\n    }\n    const filterEffect = this._ensureFilterEffect(blendMode);\n    const isRenderGroup = renderable instanceof RenderGroup;\n    const instruction = {\n      renderPipeId: \"filter\",\n      action: \"pushFilter\",\n      filterEffect,\n      renderables: isRenderGroup ? null : [renderable],\n      container: isRenderGroup ? renderable.root : null,\n      canBundle: false\n    };\n    this._renderableList = instruction.renderables;\n    instructionSet.add(instruction);\n  }\n  _ensureFilterEffect(blendMode) {\n    let filterEffect = this._filterHash[blendMode];\n    if (!filterEffect) {\n      filterEffect = this._filterHash[blendMode] = new FilterEffect();\n      filterEffect.filters = [new BLEND_MODE_FILTERS[blendMode]()];\n    }\n    return filterEffect;\n  }\n  _endAdvancedBlendMode(instructionSet) {\n    this._isAdvanced = false;\n    this._renderableList = null;\n    this._renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"filter\",\n      action: \"popFilter\",\n      canBundle: false\n    });\n  }\n  /**\n   * called when the instruction build process is starting this will reset internally to the default blend mode\n   * @internal\n   */\n  buildStart() {\n    this._isAdvanced = false;\n  }\n  /**\n   * called when the instruction build process is finished, ensuring that if there is an advanced blend mode\n   * active, we add the final render instructions added to the instruction set\n   * @param instructionSet - The instruction set we are adding to\n   * @internal\n   */\n  buildEnd(instructionSet) {\n    if (!this._isAdvanced)\n      return;\n    this._endAdvancedBlendMode(instructionSet);\n  }\n  /** @internal */\n  destroy() {\n    this._renderer = null;\n    this._renderableList = null;\n    for (const i in this._filterHash) {\n      this._filterHash[i].destroy();\n    }\n    this._filterHash = null;\n  }\n}\n/** @ignore */\nBlendModePipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"blendMode\"\n};\n\nexport { BlendModePipe };\n//# sourceMappingURL=BlendModePipe.mjs.map\n","import { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { Container } from '../../../../scene/container/Container.mjs';\nimport { Texture } from '../texture/Texture.mjs';\n\n\"use strict\";\nconst imageTypes = {\n  png: \"image/png\",\n  jpg: \"image/jpeg\",\n  webp: \"image/webp\"\n};\nconst _ExtractSystem = class _ExtractSystem {\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  _normalizeOptions(options, defaults = {}) {\n    if (options instanceof Container || options instanceof Texture) {\n      return {\n        target: options,\n        ...defaults\n      };\n    }\n    return {\n      ...defaults,\n      ...options\n    };\n  }\n  /**\n   * Creates an IImage from a display object or texture.\n   * @param options - Options for creating the image, or the target to extract\n   * @returns Promise that resolves with the generated IImage\n   * @example\n   * ```ts\n   * // Basic usage with a sprite\n   * const sprite = new Sprite(texture);\n   * const image = await renderer.extract.image(sprite);\n   * document.body.appendChild(image);\n   *\n   * // Advanced usage with options\n   * const image = await renderer.extract.image({\n   *     target: container,\n   *     format: 'webp',\n   *     quality: 0.8,\n   *     frame: new Rectangle(0, 0, 100, 100),\n   *     resolution: 2,\n   *     clearColor: '#ff0000',\n   *     antialias: true\n   * });\n   *\n   * // Extract directly from a texture\n   * const texture = Texture.from('myTexture.png');\n   * const image = await renderer.extract.image(texture);\n   * ```\n   * @see {@link ExtractImageOptions} For detailed options\n   * @see {@link ExtractSystem.base64} For base64 string output\n   * @see {@link ExtractSystem.canvas} For canvas output\n   * @see {@link ImageLike} For the image interface\n   * @category rendering\n   */\n  async image(options) {\n    const image = DOMAdapter.get().createImage();\n    image.src = await this.base64(options);\n    return image;\n  }\n  /**\n   * Converts the target into a base64 encoded string.\n   *\n   * This method works by first creating\n   * a canvas using `Extract.canvas` and then converting it to a base64 string.\n   * @param options - The options for creating the base64 string, or the target to extract\n   * @returns Promise that resolves with the base64 encoded string\n   * @example\n   * ```ts\n   * // Basic usage with a sprite\n   * const sprite = new Sprite(texture);\n   * const base64 = await renderer.extract.base64(sprite);\n   * console.log(base64); // data:image/png;base64,...\n   *\n   * // Advanced usage with options\n   * const base64 = await renderer.extract.base64({\n   *     target: container,\n   *     format: 'webp',\n   *     quality: 0.8,\n   *     frame: new Rectangle(0, 0, 100, 100),\n   *     resolution: 2\n   * });\n   * ```\n   * @throws Will throw an error if the platform doesn't support any of:\n   * - ICanvas.toDataURL\n   * - ICanvas.toBlob\n   * - ICanvas.convertToBlob\n   * @see {@link ExtractImageOptions} For detailed options\n   * @see {@link ExtractSystem.canvas} For canvas output\n   * @see {@link ExtractSystem.image} For HTMLImage output\n   * @category rendering\n   */\n  async base64(options) {\n    options = this._normalizeOptions(\n      options,\n      _ExtractSystem.defaultImageOptions\n    );\n    const { format, quality } = options;\n    const canvas = this.canvas(options);\n    if (canvas.toBlob !== void 0) {\n      return new Promise((resolve, reject) => {\n        canvas.toBlob((blob) => {\n          if (!blob) {\n            reject(new Error(\"ICanvas.toBlob failed!\"));\n            return;\n          }\n          const reader = new FileReader();\n          reader.onload = () => resolve(reader.result);\n          reader.onerror = reject;\n          reader.readAsDataURL(blob);\n        }, imageTypes[format], quality);\n      });\n    }\n    if (canvas.toDataURL !== void 0) {\n      return canvas.toDataURL(imageTypes[format], quality);\n    }\n    if (canvas.convertToBlob !== void 0) {\n      const blob = await canvas.convertToBlob({ type: imageTypes[format], quality });\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = () => resolve(reader.result);\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n      });\n    }\n    throw new Error(\"Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented\");\n  }\n  /**\n   * Creates a Canvas element, renders the target to it and returns it.\n   * This method is useful for creating static images or when you need direct canvas access.\n   * @param options - The options for creating the canvas, or the target to extract\n   * @returns A Canvas element with the texture rendered on\n   * @example\n   * ```ts\n   * // Basic canvas extraction from a sprite\n   * const sprite = new Sprite(texture);\n   * const canvas = renderer.extract.canvas(sprite);\n   * document.body.appendChild(canvas);\n   *\n   * // Extract with custom region\n   * const canvas = renderer.extract.canvas({\n   *     target: container,\n   *     frame: new Rectangle(0, 0, 100, 100)\n   * });\n   *\n   * // Extract with high resolution\n   * const canvas = renderer.extract.canvas({\n   *     target: sprite,\n   *     resolution: 2,\n   *     clearColor: '#ff0000'\n   * });\n   *\n   * // Extract directly from a texture\n   * const texture = Texture.from('myTexture.png');\n   * const canvas = renderer.extract.canvas(texture);\n   *\n   * // Extract with anti-aliasing\n   * const canvas = renderer.extract.canvas({\n   *     target: graphics,\n   *     antialias: true\n   * });\n   * ```\n   * @see {@link ExtractOptions} For detailed options\n   * @see {@link ExtractSystem.image} For HTMLImage output\n   * @see {@link ExtractSystem.pixels} For raw pixel data\n   * @category rendering\n   */\n  canvas(options) {\n    options = this._normalizeOptions(options);\n    const target = options.target;\n    const renderer = this._renderer;\n    if (target instanceof Texture) {\n      return renderer.texture.generateCanvas(target);\n    }\n    const texture = renderer.textureGenerator.generateTexture(options);\n    const canvas = renderer.texture.generateCanvas(texture);\n    texture.destroy(true);\n    return canvas;\n  }\n  /**\n   * Returns a one-dimensional array containing the pixel data of the entire texture in RGBA order,\n   * with integer values between 0 and 255 (inclusive).\n   * > [!NOE] The returned array is a flat Uint8Array where every 4 values represent RGBA\n   * @param options - The options for extracting the image, or the target to extract\n   * @returns One-dimensional Uint8Array containing the pixel data in RGBA format\n   * @example\n   * ```ts\n   * // Basic pixel extraction\n   * const sprite = new Sprite(texture);\n   * const pixels = renderer.extract.pixels(sprite);\n   * console.log(pixels[0], pixels[1], pixels[2], pixels[3]); // R,G,B,A values\n   *\n   * // Extract with custom region\n   * const pixels = renderer.extract.pixels({\n   *     target: sprite,\n   *     frame: new Rectangle(0, 0, 100, 100)\n   * });\n   *\n   * // Extract with high resolution\n   * const pixels = renderer.extract.pixels({\n   *     target: sprite,\n   *     resolution: 2\n   * });\n   * ```\n   * @see {@link ExtractOptions} For detailed options\n   * @see {@link ExtractSystem.canvas} For canvas output\n   * @see {@link ExtractSystem.image} For image output\n   * @category rendering\n   */\n  pixels(options) {\n    options = this._normalizeOptions(options);\n    const target = options.target;\n    const renderer = this._renderer;\n    const texture = target instanceof Texture ? target : renderer.textureGenerator.generateTexture(options);\n    const pixelInfo = renderer.texture.getPixels(texture);\n    if (target instanceof Container) {\n      texture.destroy(true);\n    }\n    return pixelInfo;\n  }\n  /**\n   * Creates a texture from a display object or existing texture.\n   *\n   * This is useful for creating\n   * reusable textures from rendered content or making copies of existing textures.\n   * > [!NOTE] The returned texture should be destroyed when no longer needed\n   * @param options - The options for creating the texture, or the target to extract\n   * @returns A new texture containing the extracted content\n   * @example\n   * ```ts\n   * // Basic texture extraction from a sprite\n   * const sprite = new Sprite(texture);\n   * const extractedTexture = renderer.extract.texture(sprite);\n   *\n   * // Extract with custom region\n   * const regionTexture = renderer.extract.texture({\n   *     target: container,\n   *     frame: new Rectangle(0, 0, 100, 100)\n   * });\n   *\n   * // Extract with high resolution\n   * const hiResTexture = renderer.extract.texture({\n   *     target: sprite,\n   *     resolution: 2,\n   *     clearColor: '#ff0000'\n   * });\n   *\n   * // Create a new sprite from extracted texture\n   * const newSprite = new Sprite(\n   *     renderer.extract.texture({\n   *         target: graphics,\n   *         antialias: true\n   *     })\n   * );\n   *\n   * // Clean up when done\n   * extractedTexture.destroy(true);\n   * ```\n   * @see {@link ExtractOptions} For detailed options\n   * @see {@link Texture} For texture management\n   * @see {@link GenerateTextureSystem} For texture generation\n   * @category rendering\n   */\n  texture(options) {\n    options = this._normalizeOptions(options);\n    if (options.target instanceof Texture)\n      return options.target;\n    return this._renderer.textureGenerator.generateTexture(options);\n  }\n  /**\n   * Extracts and downloads content from the renderer as an image file.\n   * This is a convenient way to save screenshots or export rendered content.\n   * > [!NOTE] The download will use PNG format regardless of the filename extension\n   * @param options - The options for downloading and extracting the image, or the target to extract\n   * @example\n   * ```ts\n   * // Basic download with default filename\n   * const sprite = new Sprite(texture);\n   * renderer.extract.download(sprite); // Downloads as 'image.png'\n   *\n   * // Download with custom filename\n   * renderer.extract.download({\n   *     target: sprite,\n   *     filename: 'screenshot.png'\n   * });\n   *\n   * // Download with custom region\n   * renderer.extract.download({\n   *     target: container,\n   *     filename: 'region.png',\n   *     frame: new Rectangle(0, 0, 100, 100)\n   * });\n   *\n   * // Download with high resolution and background\n   * renderer.extract.download({\n   *     target: stage,\n   *     filename: 'hd-screenshot.png',\n   *     resolution: 2,\n   *     clearColor: '#ff0000'\n   * });\n   *\n   * // Download with anti-aliasing\n   * renderer.extract.download({\n   *     target: graphics,\n   *     filename: 'smooth.png',\n   *     antialias: true\n   * });\n   * ```\n   * @see {@link ExtractDownloadOptions} For detailed options\n   * @see {@link ExtractSystem.image} For creating images without download\n   * @see {@link ExtractSystem.canvas} For canvas output\n   * @category rendering\n   */\n  download(options) {\n    options = this._normalizeOptions(options);\n    const canvas = this.canvas(options);\n    const link = document.createElement(\"a\");\n    link.download = options.filename ?? \"image.png\";\n    link.href = canvas.toDataURL(\"image/png\");\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n  }\n  /**\n   * Logs the target to the console as an image. This is a useful way to debug what's happening in the renderer.\n   * The image will be displayed in the browser's console using CSS background images.\n   * @param options - The options for logging the image, or the target to log\n   * @param options.width - The width of the logged image preview in the console (in pixels)\n   * @example\n   * ```ts\n   * // Basic usage\n   * const sprite = new Sprite(texture);\n   * renderer.extract.log(sprite);\n   * ```\n   * @see {@link ExtractSystem.canvas} For getting raw canvas output\n   * @see {@link ExtractSystem.pixels} For raw pixel data\n   * @category rendering\n   * @advanced\n   */\n  log(options) {\n    const width = options.width ?? 200;\n    options = this._normalizeOptions(options);\n    const canvas = this.canvas(options);\n    const base64 = canvas.toDataURL();\n    console.log(`[Pixi Texture] ${canvas.width}px ${canvas.height}px`);\n    const style = [\n      \"font-size: 1px;\",\n      `padding: ${width}px ${300}px;`,\n      `background: url(${base64}) no-repeat;`,\n      \"background-size: contain;\"\n    ].join(\" \");\n    console.log(\"%c \", style);\n  }\n  destroy() {\n    this._renderer = null;\n  }\n};\n/** @ignore */\n_ExtractSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"extract\"\n};\n/**\n * Default options for image extraction.\n * @example\n * ```ts\n * // Customize default options\n * ExtractSystem.defaultImageOptions.format = 'webp';\n * ExtractSystem.defaultImageOptions.quality = 0.8;\n *\n * // Use defaults\n * const image = await renderer.extract.image(sprite);\n * ```\n */\n_ExtractSystem.defaultImageOptions = {\n  format: \"png\",\n  quality: 1\n};\nlet ExtractSystem = _ExtractSystem;\n\nexport { ExtractSystem };\n//# sourceMappingURL=ExtractSystem.mjs.map\n","import { TextureSource } from './sources/TextureSource.mjs';\nimport { Texture } from './Texture.mjs';\n\n\"use strict\";\nclass RenderTexture extends Texture {\n  /**\n   * Creates a RenderTexture. Pass `dynamic: true` in options to allow resizing after creation.\n   * @param options - Options for the RenderTexture, including width, height, and dynamic.\n   * @returns A new RenderTexture instance.\n   * @example\n   * const rt = RenderTexture.create({ width: 100, height: 100, dynamic: true });\n   * rt.resize(500, 500);\n   */\n  static create(options) {\n    const { dynamic, ...rest } = options;\n    return new RenderTexture({\n      source: new TextureSource(rest),\n      dynamic: dynamic ?? false\n    });\n  }\n  /**\n   * Resizes the render texture.\n   * @param width - The new width of the render texture.\n   * @param height - The new height of the render texture.\n   * @param resolution - The new resolution of the render texture.\n   * @returns This texture.\n   */\n  resize(width, height, resolution) {\n    this.source.resize(width, height, resolution);\n    return this;\n  }\n}\n\nexport { RenderTexture };\n//# sourceMappingURL=RenderTexture.mjs.map\n","import { Color } from '../../../../color/Color.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { Bounds } from '../../../../scene/container/bounds/Bounds.mjs';\nimport { getLocalBounds } from '../../../../scene/container/bounds/getLocalBounds.mjs';\nimport { Container } from '../../../../scene/container/Container.mjs';\nimport { RenderTexture } from '../texture/RenderTexture.mjs';\n\n\"use strict\";\nconst tempRect = new Rectangle();\nconst tempBounds = new Bounds();\nconst noColor = [0, 0, 0, 0];\nclass GenerateTextureSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  /**\n   * Creates a texture from a display object that can be used for creating sprites and other textures.\n   * This is particularly useful for optimizing performance when a complex container needs to be reused.\n   * @param options - Generate texture options or a container to convert to texture\n   * @returns A new RenderTexture containing the rendered display object\n   * @example\n   * ```ts\n   * // Basic usage with a container\n   * const container = new Container();\n   * container.addChild(\n   *     new Graphics()\n   *         .circle(0, 0, 50)\n   *         .fill('red')\n   * );\n   *\n   * const texture = renderer.textureGenerator.generateTexture(container);\n   *\n   * // Advanced usage with options\n   * const texture = renderer.textureGenerator.generateTexture({\n   *     target: container,\n   *     frame: new Rectangle(0, 0, 100, 100), // Specific region\n   *     resolution: 2,                        // High DPI\n   *     clearColor: '#ff0000',               // Red background\n   *     antialias: true                      // Smooth edges\n   * });\n   *\n   * // Create a sprite from the generated texture\n   * const sprite = new Sprite(texture);\n   *\n   * // Clean up when done\n   * texture.destroy(true);\n   * ```\n   * @see {@link GenerateTextureOptions} For detailed texture generation options\n   * @see {@link RenderTexture} For the type of texture created\n   * @category rendering\n   */\n  generateTexture(options) {\n    if (options instanceof Container) {\n      options = {\n        target: options,\n        frame: void 0,\n        textureSourceOptions: {},\n        resolution: void 0\n      };\n    }\n    const resolution = options.resolution || this._renderer.resolution;\n    const antialias = options.antialias || this._renderer.view.antialias;\n    const container = options.target;\n    let clearColor = options.clearColor;\n    if (clearColor) {\n      const isRGBAArray = Array.isArray(clearColor) && clearColor.length === 4;\n      clearColor = isRGBAArray ? clearColor : Color.shared.setValue(clearColor).toArray();\n    } else {\n      clearColor = noColor;\n    }\n    const region = options.frame?.copyTo(tempRect) || getLocalBounds(container, tempBounds).rectangle;\n    region.width = Math.max(region.width, 1 / resolution) | 0;\n    region.height = Math.max(region.height, 1 / resolution) | 0;\n    const target = RenderTexture.create({\n      ...options.textureSourceOptions,\n      width: region.width,\n      height: region.height,\n      resolution,\n      antialias\n    });\n    const transform = Matrix.shared.translate(-region.x, -region.y);\n    this._renderer.render({\n      container,\n      transform,\n      target,\n      clearColor\n    });\n    target.source.updateMipmaps();\n    return target;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGenerateTextureSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"textureGenerator\"\n};\n\nexport { GenerateTextureSystem };\n//# sourceMappingURL=GenerateTextureSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nconst _GCSystem = class _GCSystem {\n  /**\n   * Creates a new GCSystem instance.\n   * @param renderer - The renderer this garbage collection system works for\n   */\n  constructor(renderer) {\n    /** Array of resources being tracked for garbage collection */\n    this._managedResources = [];\n    this._managedResourceHashes = [];\n    this._ready = false;\n    this._renderer = renderer;\n  }\n  /**\n   * Initializes the garbage collection system with the provided options.\n   * @param options - Configuration options\n   */\n  init(options) {\n    options = { ..._GCSystem.defaultOptions, ...options };\n    this.maxUnusedTime = options.gcMaxUnusedTime;\n    this._frequency = options.gcFrequency;\n    this.enabled = options.gcActive;\n    this.now = performance.now();\n  }\n  /**\n   * Gets whether the garbage collection system is currently enabled.\n   * @returns True if GC is enabled, false otherwise\n   */\n  get enabled() {\n    return !!this._handler;\n  }\n  /**\n   * Enables or disables the garbage collection system.\n   * When enabled, schedules periodic cleanup of resources.\n   * When disabled, cancels all scheduled cleanups.\n   */\n  set enabled(value) {\n    if (this.enabled === value)\n      return;\n    if (value) {\n      this._handler = this._renderer.scheduler.repeat(\n        () => {\n          this._ready = true;\n        },\n        this._frequency,\n        false\n      );\n    } else {\n      this._renderer.scheduler.cancel(this._handler);\n      this._handler = 0;\n    }\n  }\n  /**\n   * Called before rendering. Updates the current timestamp.\n   * @param options - The render options\n   * @param options.container - The container to render\n   */\n  prerender({ container }) {\n    this.now = performance.now();\n    container.renderGroup.gcTick = this._renderer.tick++;\n    this._updateInstructionGCTick(container.renderGroup, container.renderGroup.gcTick);\n  }\n  /** Performs garbage collection after rendering. */\n  postrender() {\n    if (!this._ready || !this.enabled)\n      return;\n    this.run();\n    this._ready = false;\n  }\n  /**\n   * Updates the GC tick counter for a render group and its children.\n   * @param renderGroup - The render group to update\n   * @param gcTick - The new tick value\n   */\n  _updateInstructionGCTick(renderGroup, gcTick) {\n    renderGroup.instructionSet.gcTick = gcTick;\n    for (const child of renderGroup.renderGroupChildren) {\n      this._updateInstructionGCTick(child, gcTick);\n    }\n  }\n  /**\n   * Registers a resource for garbage collection tracking.\n   * @param resource - The resource to track\n   * @param type - The type of resource to track\n   */\n  addResource(resource, type) {\n    if (resource._gcLastUsed !== -1) {\n      resource._gcLastUsed = this.now;\n      resource._onTouch?.(this.now);\n      return;\n    }\n    const index = this._managedResources.length;\n    resource._gcData = {\n      index,\n      type\n    };\n    resource._gcLastUsed = this.now;\n    resource._onTouch?.(this.now);\n    resource.once(\"unload\", this.removeResource, this);\n    this._managedResources.push(resource);\n  }\n  /**\n   * Removes a resource from garbage collection tracking.\n   * Call this when manually destroying a resource.\n   * @param resource - The resource to stop tracking\n   */\n  removeResource(resource) {\n    const gcData = resource._gcData;\n    if (!gcData)\n      return;\n    const index = gcData.index;\n    const last = this._managedResources.length - 1;\n    if (index !== last) {\n      const lastResource = this._managedResources[last];\n      this._managedResources[index] = lastResource;\n      lastResource._gcData.index = index;\n    }\n    this._managedResources.length--;\n    resource._gcData = null;\n    resource._gcLastUsed = -1;\n  }\n  /**\n   * Registers a hash-based resource collection for garbage collection tracking.\n   * Resources in the hash will be automatically tracked and cleaned up when unused.\n   * @param context - The object containing the hash property\n   * @param hash - The property name on context that holds the resource hash\n   * @param type - The type of resources in the hash ('resource' or 'renderable')\n   * @param priority - Processing priority (lower values are processed first)\n   */\n  addResourceHash(context, hash, type, priority = 0) {\n    this._managedResourceHashes.push({\n      context,\n      hash,\n      type,\n      priority\n    });\n    this._managedResourceHashes.sort((a, b) => a.priority - b.priority);\n  }\n  /**\n   * Performs garbage collection by cleaning up unused resources.\n   * Removes resources that haven't been used for longer than maxUnusedTime.\n   */\n  run() {\n    const now = performance.now();\n    const managedResourceHashes = this._managedResourceHashes;\n    for (const hashEntry of managedResourceHashes) {\n      this.runOnHash(hashEntry, now);\n    }\n    let writeIndex = 0;\n    for (let i = 0; i < this._managedResources.length; i++) {\n      const resource = this._managedResources[i];\n      writeIndex = this.runOnResource(resource, now, writeIndex);\n    }\n    this._managedResources.length = writeIndex;\n  }\n  updateRenderableGCTick(renderable, now) {\n    const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;\n    const currentTick = renderGroup?.instructionSet?.gcTick ?? -1;\n    if ((renderGroup?.gcTick ?? 0) === currentTick) {\n      renderable._gcLastUsed = now;\n      renderable._onTouch?.(now);\n    }\n  }\n  runOnResource(resource, now, writeIndex) {\n    const gcData = resource._gcData;\n    if (gcData.type === \"renderable\") {\n      this.updateRenderableGCTick(resource, now);\n    }\n    const isRecentlyUsed = now - resource._gcLastUsed < this.maxUnusedTime;\n    if (isRecentlyUsed || !resource.autoGarbageCollect) {\n      this._managedResources[writeIndex] = resource;\n      gcData.index = writeIndex;\n      writeIndex++;\n    } else {\n      resource.unload();\n      resource._gcData = null;\n      resource._gcLastUsed = -1;\n      resource.off(\"unload\", this.removeResource, this);\n    }\n    return writeIndex;\n  }\n  /**\n   * Creates a clone of the hash, copying all non-null entries up to (but not including) the stop key.\n   * @param hashValue - The original hash to clone from\n   * @param stopKey - The key to stop at (exclusive)\n   * @returns A new hash object with copied entries\n   */\n  _createHashClone(hashValue, stopKey) {\n    const hashClone = /* @__PURE__ */ Object.create(null);\n    for (const k in hashValue) {\n      if (k === stopKey)\n        break;\n      if (hashValue[k] !== null)\n        hashClone[k] = hashValue[k];\n    }\n    return hashClone;\n  }\n  runOnHash(hashEntry, now) {\n    const { context, hash, type } = hashEntry;\n    const hashValue = context[hash];\n    let hashClone = null;\n    let nullCount = 0;\n    for (const key in hashValue) {\n      const resource = hashValue[key];\n      if (resource === null) {\n        nullCount++;\n        if (nullCount === 1e4 && !hashClone) {\n          hashClone = this._createHashClone(hashValue, key);\n        }\n        continue;\n      }\n      if (resource._gcLastUsed === -1) {\n        resource._gcLastUsed = now;\n        resource._onTouch?.(now);\n        if (hashClone)\n          hashClone[key] = resource;\n        continue;\n      }\n      if (type === \"renderable\") {\n        this.updateRenderableGCTick(resource, now);\n      }\n      const isRecentlyUsed = now - resource._gcLastUsed < this.maxUnusedTime;\n      if (!isRecentlyUsed && resource.autoGarbageCollect) {\n        if (!hashClone) {\n          if (nullCount + 1 !== 1e4) {\n            hashValue[key] = null;\n            nullCount++;\n          } else {\n            hashClone = this._createHashClone(hashValue, key);\n          }\n        }\n        resource.unload();\n        resource._gcData = null;\n        resource._gcLastUsed = -1;\n      } else if (hashClone) {\n        hashClone[key] = resource;\n      }\n    }\n    if (hashClone) {\n      context[hash] = hashClone;\n    }\n  }\n  /** Cleans up the garbage collection system. Disables GC and removes all tracked resources. */\n  destroy() {\n    this.enabled = false;\n    this._managedResources.forEach((resource) => {\n      resource.off(\"unload\", this.removeResource, this);\n    });\n    this._managedResources.length = 0;\n    this._managedResourceHashes.length = 0;\n    this._renderer = null;\n  }\n};\n/** @ignore */\n_GCSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"gc\",\n  priority: 0\n};\n/** Default options for the GCSystem */\n_GCSystem.defaultOptions = {\n  /** Enable/disable the garbage collector */\n  gcActive: true,\n  /** Time in ms before an unused resource is collected (default 1 minute) */\n  gcMaxUnusedTime: 6e4,\n  /** How often to run garbage collection in ms (default 30 seconds) */\n  gcFrequency: 3e4\n};\nlet GCSystem = _GCSystem;\n\nexport { GCSystem };\n//# sourceMappingURL=GCSystem.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Point } from '../../../../maths/point/Point.mjs';\nimport { color32BitToUniform } from '../../../../scene/graphics/gpu/colorToUniform.mjs';\nimport { BindGroup } from '../../gpu/shader/BindGroup.mjs';\nimport { RendererType } from '../../types.mjs';\nimport { UniformGroup } from '../shader/UniformGroup.mjs';\n\n\"use strict\";\nclass GlobalUniformSystem {\n  constructor(renderer) {\n    this._stackIndex = 0;\n    this._globalUniformDataStack = [];\n    this._uniformsPool = [];\n    this._activeUniforms = [];\n    this._bindGroupPool = [];\n    this._activeBindGroups = [];\n    this._renderer = renderer;\n  }\n  reset() {\n    this._stackIndex = 0;\n    for (let i = 0; i < this._activeUniforms.length; i++) {\n      this._uniformsPool.push(this._activeUniforms[i]);\n    }\n    for (let i = 0; i < this._activeBindGroups.length; i++) {\n      this._bindGroupPool.push(this._activeBindGroups[i]);\n    }\n    this._activeUniforms.length = 0;\n    this._activeBindGroups.length = 0;\n  }\n  start(options) {\n    this.reset();\n    this.push(options);\n  }\n  bind({\n    size,\n    projectionMatrix,\n    worldTransformMatrix,\n    worldColor,\n    offset\n  }) {\n    const renderTarget = this._renderer.renderTarget.renderTarget;\n    const currentGlobalUniformData = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {\n      projectionData: renderTarget,\n      worldTransformMatrix: new Matrix(),\n      worldColor: 4294967295,\n      offset: new Point()\n    };\n    const globalUniformData = {\n      projectionMatrix: projectionMatrix || this._renderer.renderTarget.projectionMatrix,\n      resolution: size || renderTarget.size,\n      worldTransformMatrix: worldTransformMatrix || currentGlobalUniformData.worldTransformMatrix,\n      worldColor: worldColor || currentGlobalUniformData.worldColor,\n      offset: offset || currentGlobalUniformData.offset,\n      bindGroup: null\n    };\n    const uniformGroup = this._uniformsPool.pop() || this._createUniforms();\n    this._activeUniforms.push(uniformGroup);\n    const uniforms = uniformGroup.uniforms;\n    uniforms.uProjectionMatrix = globalUniformData.projectionMatrix;\n    uniforms.uResolution = globalUniformData.resolution;\n    uniforms.uWorldTransformMatrix.copyFrom(globalUniformData.worldTransformMatrix);\n    uniforms.uWorldTransformMatrix.tx -= globalUniformData.offset.x;\n    uniforms.uWorldTransformMatrix.ty -= globalUniformData.offset.y;\n    color32BitToUniform(\n      globalUniformData.worldColor,\n      uniforms.uWorldColorAlpha,\n      0\n    );\n    uniformGroup.update();\n    let bindGroup;\n    if (this._renderer.renderPipes.uniformBatch) {\n      bindGroup = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(uniformGroup, false);\n    } else {\n      bindGroup = this._bindGroupPool.pop() || new BindGroup();\n      this._activeBindGroups.push(bindGroup);\n      bindGroup.setResource(uniformGroup, 0);\n    }\n    globalUniformData.bindGroup = bindGroup;\n    this._currentGlobalUniformData = globalUniformData;\n  }\n  push(options) {\n    this.bind(options);\n    this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;\n  }\n  pop() {\n    this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1];\n    if (this._renderer.type === RendererType.WEBGL) {\n      this._currentGlobalUniformData.bindGroup.resources[0].update();\n    }\n  }\n  get bindGroup() {\n    return this._currentGlobalUniformData.bindGroup;\n  }\n  get globalUniformData() {\n    return this._currentGlobalUniformData;\n  }\n  get uniformGroup() {\n    return this._currentGlobalUniformData.bindGroup.resources[0];\n  }\n  _createUniforms() {\n    const globalUniforms = new UniformGroup({\n      uProjectionMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uWorldTransformMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      // TODO - someone smart - set this to be a unorm8x4 rather than a vec4<f32>\n      uWorldColorAlpha: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uResolution: { value: [0, 0], type: \"vec2<f32>\" }\n    }, {\n      isStatic: true\n    });\n    return globalUniforms;\n  }\n  destroy() {\n    this._renderer = null;\n    this._globalUniformDataStack.length = 0;\n    this._uniformsPool.length = 0;\n    this._activeUniforms.length = 0;\n    this._bindGroupPool.length = 0;\n    this._activeBindGroups.length = 0;\n    this._currentGlobalUniformData = null;\n  }\n}\n/** @ignore */\nGlobalUniformSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"globalUniforms\"\n};\n\nexport { GlobalUniformSystem };\n//# sourceMappingURL=GlobalUniformSystem.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Ticker } from '../../../ticker/Ticker.mjs';\n\n\"use strict\";\nlet uid = 1;\nclass SchedulerSystem {\n  constructor() {\n    this._tasks = [];\n    /** a small off set to apply to the repeat schedules. This is just to make sure they run at slightly different times */\n    this._offset = 0;\n  }\n  /** Initializes the scheduler system and starts the ticker. */\n  init() {\n    Ticker.system.add(this._update, this);\n  }\n  /**\n   * Schedules a repeating task.\n   * @param func - The function to execute.\n   * @param duration - The interval duration in milliseconds.\n   * @param useOffset - this will spread out tasks so that they do not all run at the same time\n   * @returns The unique identifier for the scheduled task.\n   */\n  repeat(func, duration, useOffset = true) {\n    const id = uid++;\n    let offset = 0;\n    if (useOffset) {\n      this._offset += 1e3;\n      offset = this._offset;\n    }\n    this._tasks.push({\n      func,\n      duration,\n      start: performance.now(),\n      offset,\n      last: performance.now(),\n      repeat: true,\n      id\n    });\n    return id;\n  }\n  /**\n   * Cancels a scheduled task.\n   * @param id - The unique identifier of the task to cancel.\n   */\n  cancel(id) {\n    for (let i = 0; i < this._tasks.length; i++) {\n      if (this._tasks[i].id === id) {\n        this._tasks.splice(i, 1);\n        return;\n      }\n    }\n  }\n  /**\n   * Updates and executes the scheduled tasks.\n   * @private\n   */\n  _update() {\n    const now = performance.now();\n    for (let i = 0; i < this._tasks.length; i++) {\n      const task = this._tasks[i];\n      if (now - task.offset - task.last >= task.duration) {\n        const elapsed = now - task.start;\n        task.func(elapsed);\n        task.last = now;\n      }\n    }\n  }\n  /**\n   * Destroys the scheduler system and removes all tasks.\n   * @internal\n   */\n  destroy() {\n    Ticker.system.remove(this._update, this);\n    this._tasks.length = 0;\n  }\n}\n/** @ignore */\nSchedulerSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"scheduler\",\n  priority: 0\n};\n\nexport { SchedulerSystem };\n//# sourceMappingURL=SchedulerSystem.mjs.map\n","import { DOMAdapter } from '../environment/adapter.mjs';\nimport { VERSION } from './const.mjs';\n\n\"use strict\";\nlet saidHello = false;\nfunction sayHello(type) {\n  if (saidHello) {\n    return;\n  }\n  if (DOMAdapter.get().getNavigator().userAgent.toLowerCase().indexOf(\"chrome\") > -1) {\n    const args = [\n      `%c  %c  %c  %c  %c PixiJS %c v${VERSION} (${type}) http://www.pixijs.com/\n\n`,\n      \"background: #E72264; padding:5px 0;\",\n      \"background: #6CA2EA; padding:5px 0;\",\n      \"background: #B5D33D; padding:5px 0;\",\n      \"background: #FED23F; padding:5px 0;\",\n      \"color: #FFFFFF; background: #E72264; padding:5px 0;\",\n      \"color: #E72264; background: #FFFFFF; padding:5px 0;\"\n    ];\n    globalThis.console.log(...args);\n  } else if (globalThis.console) {\n    globalThis.console.log(`PixiJS ${VERSION} - ${type} - http://www.pixijs.com/`);\n  }\n  saidHello = true;\n}\n\nexport { sayHello };\n//# sourceMappingURL=sayHello.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { sayHello } from '../../../../utils/sayHello.mjs';\nimport { RendererType } from '../../types.mjs';\n\n\"use strict\";\nclass HelloSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  /**\n   * It all starts here! This initiates every system, passing in the options for any system by name.\n   * @param options - the config for the renderer and all its systems\n   */\n  init(options) {\n    if (options.hello) {\n      let name = this._renderer.name;\n      if (this._renderer.type === RendererType.WEBGL) {\n        name += ` ${this._renderer.context.webGLVersion}`;\n      }\n      sayHello(name);\n    }\n  }\n}\n/** @ignore */\nHelloSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"hello\",\n  priority: -2\n};\n/** The default options for the system. */\nHelloSystem.defaultOptions = {\n  /** {@link WebGLOptions.hello} */\n  hello: false\n};\n\nexport { HelloSystem };\n//# sourceMappingURL=HelloSystem.mjs.map\n","\"use strict\";\nfunction cleanHash(hash) {\n  let clean = false;\n  for (const i in hash) {\n    if (hash[i] == void 0) {\n      clean = true;\n      break;\n    }\n  }\n  if (!clean)\n    return hash;\n  const cleanHash2 = /* @__PURE__ */ Object.create(null);\n  for (const i in hash) {\n    const value = hash[i];\n    if (value) {\n      cleanHash2[i] = value;\n    }\n  }\n  return cleanHash2;\n}\nfunction cleanArray(arr) {\n  let offset = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] == void 0) {\n      offset++;\n    } else {\n      arr[i - offset] = arr[i];\n    }\n  }\n  arr.length -= offset;\n  return arr;\n}\n\nexport { cleanArray, cleanHash };\n//# sourceMappingURL=clean.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { cleanHash, cleanArray } from '../../../../utils/data/clean.mjs';\n\n\"use strict\";\nlet renderableGCTick = 0;\nconst _RenderableGCSystem = class _RenderableGCSystem {\n  /**\n   * Creates a new RenderableGCSystem instance.\n   * @param renderer - The renderer this garbage collection system works for\n   */\n  constructor(renderer) {\n    /** Array of renderables being tracked for garbage collection */\n    this._managedRenderables = [];\n    /** Array of hash objects being tracked for cleanup */\n    this._managedHashes = [];\n    /** Array of arrays being tracked for cleanup */\n    this._managedArrays = [];\n    this._renderer = renderer;\n  }\n  /**\n   * Initializes the garbage collection system with the provided options.\n   * @param options - Configuration options for the renderer\n   */\n  init(options) {\n    options = { ..._RenderableGCSystem.defaultOptions, ...options };\n    this.maxUnusedTime = options.renderableGCMaxUnusedTime;\n    this._frequency = options.renderableGCFrequency;\n    this.enabled = options.renderableGCActive;\n  }\n  /**\n   * Gets whether the garbage collection system is currently enabled.\n   * @returns True if GC is enabled, false otherwise\n   */\n  get enabled() {\n    return !!this._handler;\n  }\n  /**\n   * Enables or disables the garbage collection system.\n   * When enabled, schedules periodic cleanup of resources.\n   * When disabled, cancels all scheduled cleanups.\n   */\n  set enabled(value) {\n    if (this.enabled === value)\n      return;\n    if (value) {\n      this._handler = this._renderer.scheduler.repeat(\n        () => this.run(),\n        this._frequency,\n        false\n      );\n      this._hashHandler = this._renderer.scheduler.repeat(\n        () => {\n          for (const hash of this._managedHashes) {\n            hash.context[hash.hash] = cleanHash(hash.context[hash.hash]);\n          }\n        },\n        this._frequency\n      );\n      this._arrayHandler = this._renderer.scheduler.repeat(\n        () => {\n          for (const array of this._managedArrays) {\n            cleanArray(array.context[array.hash]);\n          }\n        },\n        this._frequency\n      );\n    } else {\n      this._renderer.scheduler.cancel(this._handler);\n      this._renderer.scheduler.cancel(this._hashHandler);\n      this._renderer.scheduler.cancel(this._arrayHandler);\n    }\n  }\n  /**\n   * Adds a hash table to be managed by the garbage collector.\n   * @param context - The object containing the hash table\n   * @param hash - The property name of the hash table\n   */\n  addManagedHash(context, hash) {\n    this._managedHashes.push({ context, hash });\n  }\n  /**\n   * Adds an array to be managed by the garbage collector.\n   * @param context - The object containing the array\n   * @param hash - The property name of the array\n   */\n  addManagedArray(context, hash) {\n    this._managedArrays.push({ context, hash });\n  }\n  /**\n   * Updates the GC timestamp and tracking before rendering.\n   * @param options - The render options\n   * @param options.container - The container to render\n   */\n  prerender({\n    container\n  }) {\n    this._now = performance.now();\n    container.renderGroup.gcTick = renderableGCTick++;\n    this._updateInstructionGCTick(container.renderGroup, container.renderGroup.gcTick);\n  }\n  /**\n   * Starts tracking a renderable for garbage collection.\n   * @param renderable - The renderable to track\n   */\n  addRenderable(renderable) {\n    if (!this.enabled)\n      return;\n    if (renderable._lastUsed === -1) {\n      this._managedRenderables.push(renderable);\n      renderable.once(\"destroyed\", this._removeRenderable, this);\n    }\n    renderable._lastUsed = this._now;\n  }\n  /**\n   * Performs garbage collection by cleaning up unused renderables.\n   * Removes renderables that haven't been used for longer than maxUnusedTime.\n   */\n  run() {\n    const now = this._now;\n    const managedRenderables = this._managedRenderables;\n    const renderPipes = this._renderer.renderPipes;\n    let offset = 0;\n    for (let i = 0; i < managedRenderables.length; i++) {\n      const renderable = managedRenderables[i];\n      if (renderable === null) {\n        offset++;\n        continue;\n      }\n      const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;\n      const currentTick = renderGroup?.instructionSet?.gcTick ?? -1;\n      if ((renderGroup?.gcTick ?? 0) === currentTick) {\n        renderable._lastUsed = now;\n      }\n      if (now - renderable._lastUsed > this.maxUnusedTime) {\n        if (!renderable.destroyed) {\n          const rp = renderPipes;\n          if (renderGroup)\n            renderGroup.structureDidChange = true;\n          rp[renderable.renderPipeId].destroyRenderable(renderable);\n        }\n        renderable._lastUsed = -1;\n        offset++;\n        renderable.off(\"destroyed\", this._removeRenderable, this);\n      } else {\n        managedRenderables[i - offset] = renderable;\n      }\n    }\n    managedRenderables.length -= offset;\n  }\n  /** Cleans up the garbage collection system. Disables GC and removes all tracked resources. */\n  destroy() {\n    this.enabled = false;\n    this._renderer = null;\n    this._managedRenderables.length = 0;\n    this._managedHashes.length = 0;\n    this._managedArrays.length = 0;\n  }\n  /**\n   * Removes a renderable from being tracked when it's destroyed.\n   * @param renderable - The renderable to stop tracking\n   */\n  _removeRenderable(renderable) {\n    const index = this._managedRenderables.indexOf(renderable);\n    if (index >= 0) {\n      renderable.off(\"destroyed\", this._removeRenderable, this);\n      this._managedRenderables[index] = null;\n    }\n  }\n  /**\n   * Updates the GC tick counter for a render group and its children.\n   * @param renderGroup - The render group to update\n   * @param gcTick - The new tick value\n   */\n  _updateInstructionGCTick(renderGroup, gcTick) {\n    renderGroup.instructionSet.gcTick = gcTick;\n    for (const child of renderGroup.renderGroupChildren) {\n      this._updateInstructionGCTick(child, gcTick);\n    }\n  }\n};\n/**\n * Extension metadata for registering this system with the renderer.\n * @ignore\n */\n_RenderableGCSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"renderableGC\",\n  priority: 0\n};\n/**\n * Default configuration options for the garbage collection system.\n * These can be overridden when initializing the renderer.\n */\n_RenderableGCSystem.defaultOptions = {\n  /** Enable/disable the garbage collector */\n  renderableGCActive: true,\n  /** Time in ms before an unused resource is collected (default 1 minute) */\n  renderableGCMaxUnusedTime: 6e4,\n  /** How often to run garbage collection in ms (default 30 seconds) */\n  renderableGCFrequency: 3e4\n};\nlet RenderableGCSystem = _RenderableGCSystem;\n\nexport { RenderableGCSystem };\n//# sourceMappingURL=RenderableGCSystem.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { deprecation } from '../../../../utils/logging/deprecation.mjs';\n\n\"use strict\";\nconst _TextureGCSystem = class _TextureGCSystem {\n  /**\n   * Frame count since started.\n   * @readonly\n   * @deprecated since 8.15.0\n   */\n  get count() {\n    return this._renderer.tick;\n  }\n  /**\n   * Frame count since last garbage collection.\n   * @readonly\n   * @deprecated since 8.15.0\n   */\n  get checkCount() {\n    return this._checkCount;\n  }\n  set checkCount(value) {\n    deprecation(\"8.15.0\", \"TextureGCSystem.run is deprecated, please use the GCSystem instead.\");\n    this._checkCount = value;\n  }\n  /**\n   * Maximum idle frames before a texture is destroyed by garbage collection.\n   * @see TextureGCSystem.defaultMaxIdle\n   * @deprecated since 8.15.0\n   */\n  get maxIdle() {\n    return this._renderer.gc.maxUnusedTime / 1e3 * 60;\n  }\n  set maxIdle(value) {\n    deprecation(\"8.15.0\", \"TextureGCSystem.run is deprecated, please use the GCSystem instead.\");\n    this._renderer.gc.maxUnusedTime = value / 60 * 1e3;\n  }\n  /**\n   * Frames between two garbage collections.\n   * @see TextureGCSystem.defaultCheckCountMax\n   * @deprecated since 8.15.0\n   */\n  // eslint-disable-next-line dot-notation\n  get checkCountMax() {\n    return Math.floor(this._renderer.gc[\"_frequency\"] / 1e3);\n  }\n  set checkCountMax(_value) {\n    deprecation(\"8.15.0\", \"TextureGCSystem.run is deprecated, please use the GCSystem instead.\");\n  }\n  /**\n   * Current garbage collection mode.\n   * @see TextureGCSystem.defaultMode\n   * @deprecated since 8.15.0\n   */\n  get active() {\n    return this._renderer.gc.enabled;\n  }\n  set active(value) {\n    deprecation(\"8.15.0\", \"TextureGCSystem.run is deprecated, please use the GCSystem instead.\");\n    this._renderer.gc.enabled = value;\n  }\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    this._renderer = renderer;\n    this._checkCount = 0;\n  }\n  init(options) {\n    if (options.textureGCActive !== _TextureGCSystem.defaultOptions.textureGCActive) {\n      this.active = options.textureGCActive;\n    }\n    if (options.textureGCMaxIdle !== _TextureGCSystem.defaultOptions.textureGCMaxIdle) {\n      this.maxIdle = options.textureGCMaxIdle;\n    }\n    if (options.textureGCCheckCountMax !== _TextureGCSystem.defaultOptions.textureGCCheckCountMax) {\n      this.checkCountMax = options.textureGCCheckCountMax;\n    }\n  }\n  /**\n   * Checks to see when the last time a texture was used.\n   * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n   * @deprecated since 8.15.0\n   */\n  run() {\n    deprecation(\"8.15.0\", \"TextureGCSystem.run is deprecated, please use the GCSystem instead.\");\n    this._renderer.gc.run();\n  }\n  destroy() {\n    this._renderer = null;\n  }\n};\n/** @ignore */\n_TextureGCSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"textureGC\"\n};\n/**\n * Default options for the TextureGCSystem\n * @deprecated since 8.15.0\n */\n_TextureGCSystem.defaultOptions = {\n  /**\n   * If set to true, this will enable the garbage collector on the GPU.\n   * @default true\n   */\n  textureGCActive: true,\n  /**\n   * @deprecated since 8.3.0\n   * @see {@link TextureGCSystemOptions.textureGCMaxIdle}\n   */\n  textureGCAMaxIdle: null,\n  /**\n   * The maximum idle frames before a texture is destroyed by garbage collection.\n   * @default 60 * 60\n   */\n  textureGCMaxIdle: 60 * 60,\n  /**\n   * Frames between two garbage collections.\n   * @default 600\n   */\n  textureGCCheckCountMax: 600\n};\nlet TextureGCSystem = _TextureGCSystem;\n\nexport { TextureGCSystem };\n//# sourceMappingURL=TextureGCSystem.mjs.map\n","import { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation.mjs';\nimport { RenderTarget } from '../renderTarget/RenderTarget.mjs';\nimport { getCanvasTexture } from '../texture/utils/getCanvasTexture.mjs';\n\n\"use strict\";\nconst _ViewSystem = class _ViewSystem {\n  /**\n   * Whether CSS dimensions of canvas view should be resized to screen dimensions automatically.\n   * This is only supported for HTMLCanvasElement and will be ignored if the canvas is an OffscreenCanvas.\n   * @type {boolean}\n   */\n  get autoDensity() {\n    return this.texture.source.autoDensity;\n  }\n  set autoDensity(value) {\n    this.texture.source.autoDensity = value;\n  }\n  /** The resolution / device pixel ratio of the renderer. */\n  get resolution() {\n    return this.texture.source._resolution;\n  }\n  set resolution(value) {\n    this.texture.source.resize(\n      this.texture.source.width,\n      this.texture.source.height,\n      value\n    );\n  }\n  /**\n   * initiates the view system\n   * @param options - the options for the view\n   */\n  init(options) {\n    options = {\n      ..._ViewSystem.defaultOptions,\n      ...options\n    };\n    if (options.view) {\n      deprecation(v8_0_0, \"ViewSystem.view has been renamed to ViewSystem.canvas\");\n      options.canvas = options.view;\n    }\n    this.screen = new Rectangle(0, 0, options.width, options.height);\n    this.canvas = options.canvas || DOMAdapter.get().createCanvas();\n    this.antialias = !!options.antialias;\n    this.texture = getCanvasTexture(this.canvas, options);\n    this.renderTarget = new RenderTarget({\n      colorTextures: [this.texture],\n      depth: !!options.depth,\n      isRoot: true\n    });\n    this.texture.source.transparent = options.backgroundAlpha < 1;\n    this.resolution = options.resolution;\n  }\n  /**\n   * Resizes the screen and canvas to the specified dimensions.\n   * @param desiredScreenWidth - The new width of the screen.\n   * @param desiredScreenHeight - The new height of the screen.\n   * @param resolution\n   */\n  resize(desiredScreenWidth, desiredScreenHeight, resolution) {\n    this.texture.source.resize(desiredScreenWidth, desiredScreenHeight, resolution);\n    this.screen.width = this.texture.frame.width;\n    this.screen.height = this.texture.frame.height;\n  }\n  /**\n   * Destroys this System and optionally removes the canvas from the dom.\n   * @param {options | false} options - The options for destroying the view, or \"false\".\n   * @example\n   * viewSystem.destroy();\n   * viewSystem.destroy(true);\n   * viewSystem.destroy({ removeView: true });\n   */\n  destroy(options = false) {\n    const removeView = typeof options === \"boolean\" ? options : !!options?.removeView;\n    if (removeView && this.canvas.parentNode) {\n      this.canvas.parentNode.removeChild(this.canvas);\n    }\n    this.texture.destroy();\n  }\n};\n/** @ignore */\n_ViewSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"view\",\n  priority: 0\n};\n/** The default options for the view system. */\n_ViewSystem.defaultOptions = {\n  /**\n   * {@link WebGLOptions.width}\n   * @default 800\n   */\n  width: 800,\n  /**\n   * {@link WebGLOptions.height}\n   * @default 600\n   */\n  height: 600,\n  /**\n   * {@link WebGLOptions.autoDensity}\n   * @default false\n   */\n  autoDensity: false,\n  /**\n   * {@link WebGLOptions.antialias}\n   * @default false\n   */\n  antialias: false\n};\nlet ViewSystem = _ViewSystem;\n\nexport { ViewSystem };\n//# sourceMappingURL=ViewSystem.mjs.map\n","import { CustomRenderPipe } from '../../../../scene/container/CustomRenderPipe.mjs';\nimport { RenderGroupPipe } from '../../../../scene/container/RenderGroupPipe.mjs';\nimport { RenderGroupSystem } from '../../../../scene/container/RenderGroupSystem.mjs';\nimport { SpritePipe } from '../../../../scene/sprite/SpritePipe.mjs';\nimport { RendererInitHook } from '../../../../utils/global/globalHooks.mjs';\nimport { BatcherPipe } from '../../../batcher/shared/BatcherPipe.mjs';\nimport { AlphaMaskPipe } from '../../../mask/alpha/AlphaMaskPipe.mjs';\nimport { ColorMaskPipe } from '../../../mask/color/ColorMaskPipe.mjs';\nimport { StencilMaskPipe } from '../../../mask/stencil/StencilMaskPipe.mjs';\nimport { BackgroundSystem } from '../background/BackgroundSystem.mjs';\nimport { BlendModePipe } from '../blendModes/BlendModePipe.mjs';\nimport { ExtractSystem } from '../extract/ExtractSystem.mjs';\nimport { GenerateTextureSystem } from '../extract/GenerateTextureSystem.mjs';\nimport { GCSystem } from '../GCSystem.mjs';\nimport { GlobalUniformSystem } from '../renderTarget/GlobalUniformSystem.mjs';\nimport { SchedulerSystem } from '../SchedulerSystem.mjs';\nimport { HelloSystem } from '../startup/HelloSystem.mjs';\nimport { RenderableGCSystem } from '../texture/RenderableGCSystem.mjs';\nimport { TextureGCSystem } from '../texture/TextureGCSystem.mjs';\nimport { ViewSystem } from '../view/ViewSystem.mjs';\n\n\"use strict\";\nconst SharedSystems = [\n  BackgroundSystem,\n  GlobalUniformSystem,\n  HelloSystem,\n  ViewSystem,\n  RenderGroupSystem,\n  GCSystem,\n  TextureGCSystem,\n  GenerateTextureSystem,\n  ExtractSystem,\n  RendererInitHook,\n  RenderableGCSystem,\n  SchedulerSystem\n];\nconst SharedRenderPipes = [\n  BlendModePipe,\n  BatcherPipe,\n  SpritePipe,\n  RenderGroupPipe,\n  AlphaMaskPipe,\n  StencilMaskPipe,\n  ColorMaskPipe,\n  CustomRenderPipe\n];\n\nexport { SharedRenderPipes, SharedSystems };\n//# sourceMappingURL=SharedSystems.mjs.map\n"],"names":["fragment","vertex","source","MaskFilter","Filter","options","sprite","rest","textureMatrix","TextureMatrix","filterUniforms","UniformGroup","Matrix","gpuProgram","GpuProgram","glProgram","GlProgram","value","filterManager","input","output","clearMode","_BatcherPipe","renderer","adaptor","State","name","instructionSet","batchers","DefaultBatcher","i","batchableObject","batch","batches","geometry","batcher","shader","ExtensionType","BatcherPipe","extensions","textureBit","textureBitGl","tempBounds","Bounds","AlphaMaskEffect","FilterEffect","Sprite","Texture","AlphaMaskPipe","mask","maskedContainer","maskContainer","_maskedContainer","instruction","renderMask","filterEffect","BigPool","bounds","getGlobalBounds","colorTextureSource","filterTexture","TexturePool","maskData","RendererType","ColorMaskPipe","_container","colorStack","currentColor","_mask","StencilMaskPipe","_a","effect","instructionsLength","renderTargetUid","maskStackIndex","STENCIL_MODES","CLEAR","ensureAttributes","extractedData","attribute","attributeData","warn","ensureStartAndStride","buffers","attributes","tempStride","tempStart","j","buffer","getAttributeInfoFromFormat","GpuStencilModesToPixi","UboSystem","unsafeEvalSupported","uniformGroup","uniformData","Buffer","BufferUsage","uniformGroupSignature","elements","layout","syncFunction","uboElements","data","offset","uniformGroupData","dataInt32","synced","uniformParsers","createUboSyncFunction","parserCode","arrayGenerationFunction","singleSettersMap","funcFragments","prev","uboElement","parsed","template","fragmentSrc","loopMatrix","col","row","uboSyncFunctionsSTD40","uboSyncFunctionsWGSL","calculateProjection","pm","x","y","width","height","flipY","sign","canvasCache","GlobalResourceRegistry","getCanvasTexture","canvas","texture","CanvasSource","onDestroy","isRenderingToScreen","renderTarget","resource","_RenderTarget","descriptor","uid","TextureSource","colorSource","_size","resolution","skipColorTexture","colorTexture","RenderTarget","RenderTargetSystem","Rectangle","SystemRunner","target","clear","clearColor","frame","renderSurface","didChange","gpuRenderTarget","viewport","pixelWidth","pixelHeight","currentRenderTargetData","sourceRenderSurfaceTexture","destinationTexture","originSrc","size","originDest","key","BufferResource","EventEmitter","destroyBuffer","CustomRenderPipe","container","executeInstructions","renderGroup","instructions","tempMatrix","RenderGroupPipe","batchableRenderGroup","BatchableSprite","worldTransformMatrix","clearList","list","index","tempContainer","Container","UPDATE_BLEND_COLOR_VISIBLE","UPDATE_VISIBLE","UPDATE_COLOR","UPDATE_BLEND","updateRenderGroupTransforms","updateChildRenderGroups","updateRenderGroupTransform","childrenToUpdate","updateTick","renderGroupDepth","childrenAtDepth","child","updateTransformAndChildren","root","worldAlpha","renderGroupParent","multiplyColors","updateFlags","localTransform","parent","updateColorBlendVisibility","children","length","renderable","groupAlpha","validateRenderables","renderPipes","rebuildRequired","RenderGroupSystem","transform","originalLocalTransform","closestCacheAsTexture","lastTexture","antialias","scaleMode","TextureStyle","rendererOrPipes","SpritePipe","gpuSprite","batchableSprite","_BackgroundSystem","Color","BackgroundSystem","BLEND_MODE_FILTERS","BlendModePipe","blendMode","isRenderGroup","RenderGroup","imageTypes","_ExtractSystem","defaults","image","DOMAdapter","format","quality","resolve","reject","blob","reader","pixelInfo","link","base64","style","ExtractSystem","RenderTexture","dynamic","tempRect","noColor","GenerateTextureSystem","region","getLocalBounds","_GCSystem","gcTick","type","gcData","last","lastResource","context","hash","priority","a","b","now","managedResourceHashes","hashEntry","writeIndex","currentTick","hashValue","stopKey","hashClone","k","nullCount","GCSystem","GlobalUniformSystem","projectionMatrix","worldColor","currentGlobalUniformData","Point","globalUniformData","uniforms","color32BitToUniform","bindGroup","BindGroup","SchedulerSystem","Ticker","func","duration","useOffset","id","task","elapsed","saidHello","sayHello","args","VERSION","HelloSystem","cleanHash","clean","cleanHash2","cleanArray","arr","renderableGCTick","_RenderableGCSystem","array","managedRenderables","rp","RenderableGCSystem","_TextureGCSystem","deprecation","_value","TextureGCSystem","_ViewSystem","v8_0_0","desiredScreenWidth","desiredScreenHeight","ViewSystem","SharedSystems","RendererInitHook","SharedRenderPipes"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43]}